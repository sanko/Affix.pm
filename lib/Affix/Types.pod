=encoding utf-8

=head1 NAME

Affix::Types - Native and User-defined Type Representation

=head1 SYNOPSIS

    use Affix qw[:types];

=head1 Description

Raku offers a set of native types with a fixed, and known, representation in
memory but this is Perl so we need to do the work ourselves and design and
build a pseudo-type system.

This page shows which ones exist and how they can be used.

=head1 Types with native representation

Some simple types in typed languages have a native representation here,
indicating that they will use the C language representation provided by the
compiler, operating system and machine. These are the four native types
available:

    Type        C99/C++     Rust    C#          pack()  Raku
    -----------------------------------------------------------------------
    Void        void/NULL   ->()    void/NULL   -
    Bool        _Bool       bool    bool        -       bool
    Char        int8_t      i8      sbyte       c       int8
    UChar       uint8_t     u8      byte        C       byte, uint8
    Short       int16_t     i16     short       s       int16
    UShort      uint16_t    u16     ushort      S       uint16
    Int         int32_t     i32     int         i       int32
    UInt        uint32_t    u32     uint        I       uint32
    Long        int64_t     i64     long        l       int64, long
    ULong       uint64_t    u64     ulong       L       uint64, ulong
    LongLong    -           i128                q       longlong
    ULongLong   -           u128                Q       ulonglong
    Float       float       f32                 f       num32
    Double      double      f64                 d       num64
    SSize_t     ssize_t                                 ssize_t
    Size_t      size_t                                  size_t
    Str         char *

Given sizes are minimums measured in bits

=head2 The C<Void> type

The C<Void> type corresponds to the C C<void> type. It is generally found in
typed pointers representing the equivalent to the C<void *> pointer in C.

    sub malloc :Native :Signature([Size_t] => Pointer[Void]);
    my $data = malloc( 32 );

As the example shows, it's represented by a parameterized C<Pointer> type,
using as parameter whatever the original pointer is pointing to (in this case,
C<void>). This role represents native pointers, and can be used wherever they
need to be represented in a Perl script.

You'll learn a bit more about parameterized types in the next section.

=head1 Parameterized types

Some types can or must be provided with

=head2 ArrayRef

The elements of the array must pass the additional constraint. For example
C<ArrayRef[Int]> should be a reference to an array of numbers.

An array length must be given:

    ArrayRef[Int, 5];   # int arr[5]
    ArrayRef[Any, 20];  # SV * arr[20]
    ArrayRef[Char, 5];  # char arr[5]
    ArrayRef[Str, 10];  # char *arr[10]

=head2 CodeRef

A value where C<ref($value)> equals C<CODE>.

The argument list and return value must pass the additional constraint. For
example, C<CodeRef[[Int, Int]=>Int]> C<typedef int (*fuc)(int a, int b);>; that
is function that accepts two integers and returns an integer.

    CodeRef[[] => Void]; # typedef void (*function)();
    CodeRef[[Pointer[Int]] => Int]; # typedef Int (*function)(int * a);
    CodeRef[[Str, Int] => Struct[...]]; # typedef struct Person (*function)(chat * name, int age);

=head2 Enum

The value of an C<Enum> is defined by its underlying type which includes
C<Int>, C<Char>, etc.

This type is declared with an list of strings.

    Enum[ 'ALPHA', 'BETA' ];
    # ALPHA = 0
    # BETA  = 1

Unless an enumeration constant is defined in an array reference, its value is
the value one greater than the value of the previous enumerator in the same
enumeration. The value of the first enumerator (if it is not defined) is zero.

    Enum[ 'A', 'B', [C => 10], 'D', [E => 1], 'F', [G => 'F + C'] ];
    # A = 0
    # B = 1
    # C = 10
    # D = 11
    # E = 1
    # F = 2
    # G = 12

    Enum[ [ one => 'a' ], 'two', [ 'three' => 'one' ] ]
    # one   = a
    # two   = b
    # three = a

Additionally, if you C<typedef> the enum into a given namespace, you may refer
to elements by name:

    typedef color => Enum[ 'RED', 'GREEN', 'BLUE' ];
    print color::RED();     # RED
    print int color::RED(); # 0

=head2 InstanceOf

=head2 Pointer

    Pointer[Void]
    Pointer[Int]

=head2 Struct

=head2 Union

=head1 Opaque types

=head2 Any

Any value you may pass without modification to the attached function. This
means the native C<AV *>, C<CV *>, C<HV *>, C<SV *>, etc.

=head2 Opaque



=head1 See Also

L<Types::Standard>

L<https://docs.raku.org/language/nativetypes>

Examples found in C<eg/>.

=head1 LICENSE

Copyright (C) Sanko Robinson.

This library is free software; you can redistribute it and/or modify it under
the terms found in the Artistic License 2. Other copyrights, terms, and
conditions may apply to data transmitted through this module.

=head1 AUTHOR

Sanko Robinson E<lt>sanko@cpan.orgE<gt>

=begin stopwords

dyncall enum

=end stopwords

=cut
