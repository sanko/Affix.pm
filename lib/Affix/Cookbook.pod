=pod

=encoding utf-8

=head1 NAME

Affix::Cookbook - Recipes for bridging Perl and C without the pain of XS

=head1 DESCRIPTION

Welcome to the Affix Cookbook.

For decades, the barrier between Perl and the raw speed of C (or Rust, or C++, or Fortran) has been guarded by the
complex, arcane rituals of XS. You had to learn a new macro language, configure a build system, handle the Perl stack
manually, and compile everything before you could even run a "Hello World".

Affix changes the menu.

Affix is a Foreign Function Interface (FFI) built on the low-overhead L<infix|https://github.com/sanko/infix/> JIT
engine. It allows you to bind libraries, marshal complex data structures, and manage memory dynamically, all from
within your Perl script.

=head2 What is in this Cookbook?

This document is a collection of recipes designed to take you from a hungry beginner to a master chef of systems
programming.

We will cover:

=over

=item * B<The Basics:> Calling standard C library functions like C<printf> and C<pow>.

=item * B<The Compiler:> Using L<Affix::Compiler> to write C code directly inside your Perl scripts for instant optimization.

=item * B<Memory Management:> Understanding Pointers, Pins, and how to allocate memory without leaking it.

=item * B<Advanced Structures:> Handling C Structs, Unions, and Arrays as easily as Perl Hashes and Lists.

=item * B<The Exotic:> Callbacks, Function Pointers, and SIMD Vector mathematics.

=back

You'll also find benchmarks against other projects here, the results presented are taken from my system running Windows
11 Pro on an AMD Ryzen 7 7840HS, 32Gb of RAM, with Strawberry Perl 5.42.0.

=head2 Prerequisites

To follow these recipes, you will need:

=over

=item * B<Perl v5.40> or higher (Affix leverages modern Perl features like C<class>).

=item * B<Affix> installed from CPAN.

=item * A C compiler (GCC, Clang, or MSVC) is highly recommended for the advanced recipes, though not strictly required for binding to existing system libraries.

=back

Grab your apron. Let's get cooking.

=head1 Chapter 1: The Instant C Library

Sometimes, you don't have a pre-existing F<.dll> or F<.so> file. Sometimes, you just have an idea, a heavy mathematical
loop, or a snippet of C code you found on Stack Overflow, and you want to run it I<right now> inside your Perl script.

This is where C<Affix::Compiler> shines. It turns your Perl script into a build system, a linker, and a loader, all in
about five lines of code.

Let's look at the classic "Hello World" of pointer manipulation: the Integer Swap.

=head2 The Recipe

    use v5.40;
    use Affix;
    use Affix::Compiler;

    # 1. Spin up the compiler
    my $c = Affix::Compiler->new();

    # 2. Add some C code directly into the script
    $c->add( \<<~'', lang => 'c' );
        void swap(int *a, int *b) {
            int tmp = *b;
            *b = *a;
            *a = tmp;
        }

    # 3. Compile, Link, and Bind
    affix $c->link, swap => [ Pointer [Int], Pointer [Int] ] => Void;

    # 4. Profit
    my $a = 1;
    my $b = 2;

    say "Before: [a,b] = [$a, $b]";

    # Pass references so C can write back to Perl
    swap( \$a, \$b );

    say "After:  [a,b] = [$a, $b]";

=head2 How It Works

This creates a seamless bridge between the two languages. Here is what is happening under the hood:

=over

=item B<1. The Builder>

C<Affix::Compiler-E<gt>new()> creates a temporary workspace. It detects your operating system (Windows, Linux, macOS,
BSD) and hunts for a viable compiler chain (GCC, Clang, MSVC). You don't need to configure Makefiles or worry about
linker flags; the class handles the heavy lifting.

=item B<2. The Source>

We pass the source code as a B<reference to a string> (C<\<<~''>). This tells the compiler, "I'm not giving you a
filename; I'm giving you the raw code." We specify C<lang =E<gt> 'c'>, but C<Affix::Compiler> is a polyglot‚Äîit could
just as easily have been C<cpp>, C<rust>, or C<fortran>.

=item B<3. The Link>

Calling C<$c-E<gt>link> triggers the build process. It writes your source to a temp file, compiles it into an object
file, and links it into a dynamic library. It returns the absolute path to that library (e.g., F</tmp/affix_lib.so>).

We pass that path immediately to C<affix>, binding the symbol C<swap>.

=item B<4. The Types>

This is the most critical part of this recipe:

    [ Pointer [Int], Pointer [Int] ]

If we had defined this as C<[ Int, Int ]>, Affix would have passed the I<values> C<1> and C<2> to C. The C code would
have swapped those values in its own local stack and returned, leaving our Perl variables untouched.

By specifying C<Pointer>, we tell Affix we expect a memory address.

=item B<5. The Execution>

Because we defined the types as Pointers, we must pass B<references> to our Perl scalars:

    swap( \$a, \$b );

Affix takes the memory address of the SV (Scalar Value) holding C<$a>, passes it to C, and allows the C code to
overwrite the memory directly. When C<swap> returns, C<$a> sees the data that was previously in C<$b>.

=back

=head2 Kitchen Reminders

=over

=item * B<Compiler Required>

While C<Affix> works on any machine, C<Affix::Compiler> obviously requires a C compiler (like C<gcc>, C<clang>, or
Visual Studio) to be in your system's C<PATH>.

=item * B<Automatic Cleanup>

By default, C<Affix::Compiler> creates a temporary directory for the build artifacts. When your script ends, that
directory is wiped clean. If you want to inspect the generated C files or the F<.so> library for debugging, pass
C<clean =E<gt> 0> to the constructor:

    my $c = Affix::Compiler->new( clean => 0, debug => 1 );

=item * B<Type Safety>

C is unforgiving. If you tell Affix the argument is a C<Pointer[Int]>, but you pass a string like C<"Hello">, Affix
will try to make it work, but the C code effectively interprets the bytes of that string as an integer. Always match
your Perl data types to your Affix definitions.

=back

=head1 Chapter 2: Speaking Windows (Unicode)

When interacting with the Windows API (Win32), you will inevitably face two facts: libraries are named things like
F<user32.dll>, and text is almost always expected to be UTF-16 (Wide Characters).

Perl works natively in UTF-8. In the old days of XS, bridging this gap involved tedious calls to C<MultiByteToWideChar>
and manual buffer management.

Affix handles the translation for you.

=head2 The Recipe

This recipe displays a native Windows message box containing Unicode characters (an emoji).

    use v5.40;
    use utf8; # Required for literal emojis in source
    use Affix;

    # Define some standard Windows constants
    use constant MB_OK                   => 0x00000000;
    use constant MB_DEFAULT_DESKTOP_ONLY => 0x00020000;

    # Bind the function
    # Library: user32.dll
    # Symbol:  MessageBoxW (The Unicode version)
    # Alias:   MessageBox  (What we call it in Perl)
    affix 'user32', [ MessageBoxW => 'MessageBox' ] =>
        [ Pointer [Void], WString, WString, UInt ] => Int;

    # Call it
    # undef becomes NULL (No owner window)
    MessageBox( undef, 'Keep your stick on the ice.', 'üèí', MB_OK | MB_DEFAULT_DESKTOP_ONLY );

=head2 How It Works

=over

=item B<1. The A vs. W Suffix>

Most Windows functions come in two flavors: B<ANSI> (ending in C<A>) and B<Wide> (ending in C<W>). C<MessageBoxA>
expects system-codepage strings (like ASCII), while C<MessageBoxW> expects UTF-16.

Since modern Perl is Unicode-aware, we almost always want the B<W> version.

=item B<2. Aliasing>

We bind the symbol C<MessageBoxW>, but that is a clumsy name to type in Perl. By passing an array reference C<[
'MessageBoxW' =E<gt> 'MessageBox' ]>, we tell Affix to look up the real symbol in the DLL but install it into our
namespace as C<MessageBox>.

=item B<3. The WString Type>

This is the magic ingredient.

    [ ..., WString, WString, ... ]

When you pass a Perl string to a C<WString> argument, Affix performs the following steps on the fly:

=over

=item 1. Check the internal encoding of the Perl scalar.

=item 2. Transcode the string into UTF-16LE (Little Endian).

=item 3. Append a double-null terminator (C<\0\0>).

=item 4. Pass the pointer to the C function.

=back

This allows us to pass the hockey stick emoji C<'üèí'> directly.

=item B<4. The Null Pointer>

The first argument to C<MessageBox> is a handle to an owner window (C<HWND>). Since we don't have a parent window, we
pass C<NULL>.

In Affix, C<NULL> is represented by Perl's C<undef>. When passed to a C<Pointer> type, C<undef> is automatically
converted to address C<0x0>.

=back

=head2 Kitchen Reminders

=over

=item * B<Input Only>

The C<WString> type is designed for B<input> strings (C<LPCWSTR> or C<const wchar_t*>). Affix creates a temporary
buffer for the duration of the call. If the C function intends to I<modify> the string buffer, you must use
C<Pointer[WChar]> and manage the memory yourself using C<calloc>.

=item * B<Use utf8>

If you are typing special characters like 'üèí' directly into your Perl script, always remember C<use utf8;> at the
top of your file, or Perl might interpret the bytes incorrectly before Affix even sees them.

=back

=head1 Chapter 3: Binary Data (The Null Byte Trap)

C strings are simple: they start at a memory address and end at the first zero byte (C<\0>).

But what if your data I<contains> zeros? If you use standard string types like C<String> or C<Array[Char]>, C (and
Affix) will assume the data ends at the first null byte. This is fatal for encryption, compression, and binary formats.

To handle this, we must stop thinking in B<Characters> and start thinking in B<Bytes>.

=head2 The Recipe

We will modify the XOR Cipher example. Since the data might contain nulls, we handle it as a raw buffer.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile the C library
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        #include <stdlib.h>
        #include <string.h>

        char * string_crypt(const char * input, int len, const char * key) {
            char * output = malloc(len + 1);
            if (!output) return NULL;
            output[len] = '\0';

            int key_len = strlen(key);
            for (int i = 0; i < len; i++) {
                output[i] = input[i] ^ key[i % key_len];
            }
            return output;
        }

        void string_free(void * p) { free(p); }
    END

    my $lib = $c->link;

    # 2. Bind the functions
    # Return Pointer[Void] to get the raw address (Pin) without interpretation.
    affix $lib, 'string_crypt', [ String, Int, String ] => Pointer[Void];
    affix $lib, 'string_free',  [ Pointer[Void] ]       => Void;

    # 3. The Wrapper
    sub cipher( $input, $key ) {
        my $len = length($input);

        # Call C. We get back a Pin (unmanaged pointer).
        my $ptr = string_crypt( $input, $len, $key );
        return undef if is_null($ptr);

        # Create a view of the memory as an Array of Bytes (UInt8).
        # Important:
        #   Array[Char]  => Reads up to NULL (String behavior)
        #   Array[UInt8] => Reads exactly $len bytes (Binary behavior)
        my $view = cast( $ptr, Array[UInt8, $len] );

        # Dereference the view ($$view).
        # For byte arrays, Affix returns a binary string directly.
        my $binary_string = $$view;

        # Clean up the C memory immediately
        string_free($ptr);

        return $binary_string;
    }

    # 4. Run it
    my $orig = 'hello world!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!';
    my $key  = 'foobar';

    my $enc = cipher( $orig, $key );
    my $dec = cipher( $enc,  $key );

    say "Original:  $orig";
    say "Decrypted: $dec";

    # Verify the binary data size
    say "Encrypted length: " . length($enc);

    use JSON::PP;
    say "Encrypted blob:   " . encode_json([$enc]);

=head2 How It Works

=over

=item B<1. Pointer[Void]>

We define the return type as C<Pointer[Void]> to prevent Affix from automatically attempting to read it as a
null-terminated string. We receive a raw B<Pin>.

=item B<2. Casting to Array[UInt8]>

    my $view = cast( $ptr, Array[UInt8, $len] );

We use C<UInt8> (unsigned 8-bit integer) instead of C<Char>. This tells Affix we are dealing with raw binary data, not
text. Affix will read exactly C<$len> bytes from memory, regardless of nulls.

=item B<3. Dereferencing>

    my $binary_string = $$view;

When you dereference a Pin defined as an C<Array> of 8-bit types, Affix optimizes the operation. It copies the raw
bytes directly into a Perl scalar.

=back

=head2 Kitchen Reminders

=over

=item * B<Char vs UInt8>

In Affix, C<Array[Char]> is treated as a string buffer (stops at null). C<Array[UInt8]> is treated as a byte buffer
(reads full length). Use the one matching your data.

=back

=head1 Chapter 4: Strings and Static State

Dealing with C strings usually involves asking "Who owns this memory?"

In Perl, strings are values. In C, they are pointers. A common (though not thread-safe) pattern in C libraries is to
return a pointer to an internal static buffer. This buffer is overwritten or freed the next time the function is
called.

If you were using raw pointers, this would be dangerous; your Perl variable would suddenly change its value or point to
freed memory when you made a subsequent API call.

Affix solves this by copying string return values into Perl's memory space immediately.

=head2 The Recipe

In this example, we implement a C function that remembers its last result. It frees the old result before allocating a
new one. We use a final call with C<undef> to trigger a cleanup.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile the C library
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        #include <stdlib.h>
        #include <string.h>

        const char * string_reverse(const char * input) {
            // Static pointer persists across function calls
            static char * output = NULL;
            int i, len;

            // Cleanup previous call's memory
            if (output != NULL) {
                free(output);
                output = NULL;
            }

            // Handle "Cleanup Mode" (NULL input)
            if (input == NULL)
                return NULL;

            // Allocate new buffer
            len = strlen(input);
            output = malloc(len + 1);

            // Reverse the string
            for (i = 0; input[i]; i++)
                output[len - i - 1] = input[i];
            output[len] = '\0';

            return output;
        }
    END

    my $lib = $c->link;

    # 2. Bind the function
    # String means "const char*" for input and output.
    affix $lib, 'string_reverse', [String] => String;

    # 3. Use it
    # Input:  "\nHello world"
    # Output: "dlrow olleH\n"
    print string_reverse("\nHello world");

    # 4. Cleanup
    # Passing undef sends NULL to C, triggering the free() logic.
    string_reverse(undef);

=head2 How It Works

=over

=item B<1. Passing Strings (Input)>

    [ String ] => ...

When passing a Perl string to a C<String> argument, Affix temporarily allocates a C buffer, copies the Perl string
(encoded as UTF-8), and passes that pointer to C. This buffer is valid only for the duration of the call.

=item B<2. Returning Strings (Output)>

    ... => String

When a C function returns a C<String> type, Affix reads the memory at that address (up to the first null byte), creates
a B<new> Perl scalar containing those bytes, and returns the scalar.

It does B<not> return a pointer to the C memory.

This is crucial for this recipe. Even though the C function eventually calls C<free(output)> on the next invocation,
our Perl variable holding C<"dlrow olleH\n"> remains safe because it is a distinct copy.

=item B<3. Passing Undef>

    string_reverse(undef);

For string arguments, C<undef> is marshalled as C<NULL> (0x0). Our C function checks for this to perform its cleanup
duties.

=back

=head2 Kitchen Reminders

=over

=item * B<Copy vs. Reference>

If you want a copy of the text (standard Perl behavior), use the type C<String>. If you want to modify the C memory
buffer in place or hold onto the specific memory address, use C<Pointer[Char]> (see Chapter 3).

=item * B<Thread Safety>

While Affix is thread-safe, C functions using C<static> variables (like the one in this recipe) are generally B<not>
thread-safe. If two threads call C<string_reverse> at the same time, they will race to free/overwrite the same static
pointer.

=back

=head1 Chapter 5: The Standard Library (Hello World)

Every operating system comes with a "Standard C Library" (libc). It contains the fundamental building blocks of C
programming: memory allocation, file I/O, string manipulation, and system calls.

Affix provides a shortcut to access this library without you needing to know its exact filename (which varies wildly
between Linux, macOS, and Windows).

=head2 The Recipe

We will bind the standard C function C<puts> (put string). It takes a string, prints it to Standard Output (stdout),
and appends a newline character.

    use v5.40;
    use Affix;

    # 1. Bind
    # libc is a helper function exported by Affix.
    # It returns the handle to the system's standard library.
    affix libc, 'puts' => [String] => Int;

    # 2. Call
    # Note: puts() automatically adds a newline "\n"
    puts('Hello World');

    # 3. Check Result
    # puts returns a non-negative integer on success, or EOF (-1) on error.
    my $ret = puts('Affix makes FFI easy.');
    if ($ret >= 0) {
        say "Successfully wrote to stdout.";
    }

=head2 How It Works

=over

=item B<1. The C<libc> Helper>

Finding the standard library is platform-dependent:

=over

=item * Linux: F<libc.so.6> (usually)

=item * macOS: F<libSystem.B.dylib>

=item * Windows: F<msvcrt.dll> (or F<ucrtbase.dll>)

=back

The C<libc> function (exported by Affix) handles this detection logic for you, returning the correct handle for your
operating system.

=item B<2. The C<puts> Function>

The C signature for `puts` is:

    int puts(const char *s);

We map this to:

    [String] => Int

When you call C<puts('Hello')>, Affix takes your Perl string, ensures it is null-terminated, and passes the pointer to
C. The C library writes the bytes to the file descriptor for STDOUT.

=back

=head2 Kitchen Reminders

=over

=item * B<Output Buffering>

Perl and C use their own IO buffers. If you mix C<print "...">, C<say "...">, and C<puts(...)> in the same script, the
output might appear out of order depending on when the buffers are flushed. Setting C<$| = 1;> in Perl usually helps,
but doesn't strictly control the C buffer.

=item * B<Implicit Newlines>

Unlike Perl's C<print>, C<puts> always adds a newline. If you want to print without a newline using C, you would need
to bind C<printf> (which is a variadic function‚Äîsee the Variadic recipes).

=back

=head1 Chapter 6: Opaque Pointers (C++)

Perl cannot directly instantiate a C++ class or read a C struct unless we define every single field in Affix. Often, we
don't care about the fields. We just want to hold onto the object and pass it back to the library later.

This pattern is called the **Opaque Pointer** (or Opaque Handle). We treat the object as a black box (C<Pointer[Void]>)
and use helper functions to interact with it.

=head2 The Recipe

We will create a simple C++ `Person` struct, wrap it with C-compatible helpers, and bind it to Perl.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile the C++ Library
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'cpp' );
        #include <stdlib.h>
        #include <string.h>

        typedef struct {
            char * name;
            unsigned int age;
        } Person;

        // extern "C" prevents C++ Name Mangling.
        // This ensures the symbols in the DLL are just "person_new",
        // not "_Z10person_newPKcj".
        extern "C" {

            Person * person_new(const char * name, unsigned int age) {
                Person * self = (Person *) malloc(sizeof(Person));
                self->name = strdup(name);
                self->age = age;
                return self;
            }

            const char * person_name(Person * self) {
                return self->name;
            }

            unsigned int person_age(Person * self) {
                return self->age;
            }

            void person_free(Person * self) {
                if (self) {
                    free(self->name);
                    free(self);
                }
            }
        }
    END

    my $lib = $c->link;

    # 2. Define the Opaque Type
    # We tell Affix: "Whenever you see 'Person', treat it as a void pointer."
    typedef Person => Pointer[Void];

    # 3. Bind
    # Notice we use Person() as the type.
    affix $lib, 'person_new',  [ String, UInt ] => Person();
    affix $lib, 'person_name', [ Person() ]     => String;
    affix $lib, 'person_age',  [ Person() ]     => UInt;
    affix $lib, 'person_free', [ Person() ]     => Void;

    # 4. Use
    my $roger = person_new( 'Roger Frooble Bits', 35 );

    # $roger is just a blessed scalar holding a memory address.
    # We pass it back to C to get data.
    say "Name: " . person_name($roger);
    say "Age:  " . person_age($roger);

    # Clean up
    person_free($roger);

=head2 How It Works

=over

=item B<1. extern "C">

C++ compilers "mangle" function names (e.g., C<person_new> becomes C<_Z10person_newPKcj>) to support function
overloading. This is a nightmare to bind. Wrapping your helper functions in C<extern "C"> forces the compiler to use
standard C names.

=item B<2. The Shim Pattern>

We didn't bind the C++ struct fields directly. Instead, we wrote small C helper functions (Shims) to access the data:

    const char * person_name(Person * self) { return self->name; }

This insulates your Perl code from changes in the C++ class layout.

=item B<3. Typedef Aliases>

    typedef Person => Pointer[Void];

This creates a named alias. While C<Pointer[Void]> works, using C<Person()> in your signatures makes the code
self-documenting. It also prevents accidents‚Äîif you later define C<Car => Pointer[Void]>, Affix won't stop you from
passing a Car to a Person function (since they are both just pointers), but your code will be much easier to read and
debug.

=back

=head2 Kitchen Reminders

=over

=item * B<Constructors must Return>

It seems obvious, but in C++, forgetting to C<return self;> in a constructor function is easy to do and leads to
immediate Segfaults or Illegal Instruction errors.

=item * B<Memory Ownership>

Since C<person_new> used C<malloc>, the memory belongs to the C heap. You must explicitly call C<person_free> to
release it. Affix cannot garbage collect these opaque pointers automatically unless you attach a destructor using
Perl's C<DESTROY> (which is an advanced topic for another chapter).

=back

=head1 Chapter 7: System Libraries (Desktop Notifications)

Perl scripts often live in the terminal, but they don't have to stay there.

On Linux (and BSDs with a desktop environment), the C<libnotify> library allows applications to send pop-up
notifications to the user. These are the bubbles you see from apps like Slack, Discord, or your system updater.

This library uses the GLib object system (GObject), which is notoriously complex to bind manually. However, if we only
want to trigger a notification, we can treat the objects as B<Opaque Pointers> and ignore the internal complexity
entirely.

=head2 The Recipe

    use v5.40;
    use Affix;

    # 1. Find the library
    # locate_lib searches system paths (like /usr/lib) for libnotify.so
    # It returns the full path as a string.
    my $libnotify = Affix::locate_lib('notify');

    unless ($libnotify) {
        die "Could not find libnotify. Are you on Linux with libnotify-bin installed?";
    }

    # 2. Bind the lifecycle functions
    # bool notify_init(const char *app_name);
    affix $libnotify, 'notify_init',   [String] => Bool;
    affix $libnotify, 'notify_uninit', []       => Void;

    # 3. Bind the object functions
    # NotifyNotification* notify_notification_new(const char *summary, const char *body, const char *icon);
    affix $libnotify, 'notify_notification_new',
        [ String, String, String ] => Pointer[Void];

    # bool notify_notification_show(NotifyNotification *notification, GError **error);
    affix $libnotify, 'notify_notification_show',
        [ Pointer[Void], Pointer[Void] ] => Bool;

    # 4. Use it
    # Initialize the library with our app name
    notify_init('Affix üèí');

    # Create the notification object
    # We get back a Pin (opaque pointer), but we don't need to look inside it.
    my $n = notify_notification_new(
        'Keep your stick on the ice!',
        "Hello from Affix!\nWelcome to the fun world of FFI.",
        'dialog-information' # Standard icon name
    );

    # Show it
    # We pass undef for the second argument (GError**), meaning "ignore errors".
    notify_notification_show( $n, undef );

    # Clean up
    notify_uninit();

=head2 How It Works

=over

=item B<1. Locating Libraries>

    my $libnotify = Affix::locate_lib('notify');

Unlike C<load_library> (which loads the DLL into memory immediately), C<locate_lib> scans the system's dynamic linker
paths (like C<LD_LIBRARY_PATH>) and returns the filename. We pass this path to C<affix>, which handles the loading.

=item B<2. Ignoring Complexity>

The C<notify_notification_new> function returns a C<NotifyNotification*>. In C, this is a struct with many private
fields and GObject metadata. In Perl, we don't care. We define the return type as C<Pointer[Void]>.

As long as we pass that pointer back to other functions in the same library (like C<notify_notification_show>),
everything works.

=item B<3. Optional Error Handling>

The C signature for C<show> is:

    gboolean notify_notification_show (NotifyNotification *notification, GError **error);

The second argument is a pointer-to-a-pointer that the library fills if an error occurs. By passing C<undef>, Affix
sends a C<NULL>, telling the library we don't want to receive error details.

=back

=head2 Kitchen Reminders

=over

=item * B<Platform Specific>

This recipe works on Linux/BSD with a freedesktop.org compliant notification daemon (GNOME, KDE, XFCE, etc.). It will
likely fail to find the library on Windows or vanilla macOS.

=item * B<Unicode>

Notice we used an emoji in the app name: C<'Affix üèí'>. Because we used the C<String> type, Affix automatically
encoded this as UTF-8, which is what modern Linux libraries expect.

=back

=head1 Chapter 8: Manual Memory Management

Perl handles memory for you. C does not. When you start allocating raw memory buffers in Affix, you are stepping into
the C world.

This recipe demonstrates how to manually allocate, manipulate, and free memory using the standard C lifecycle.

=head2 The Recipe

    use v5.40;
    use Affix qw[:all];

    # 1. Allocation
    # We allocate 14 bytes.
    # malloc returns a Pointer[Void] (a Pin).
    my $void_ptr = malloc( 14 );

    # 2. String Duplication
    # strdup allocates new memory containing a copy of the string.
    my $ptr_string = strdup("hello there!!\n");

    # 3. Memory Copy
    # We copy 15 bytes (text + null terminator) from one pointer to another.
    # memcpy works on raw pointers, so passing $void_ptr is fine.
    memcpy( $void_ptr, $ptr_string, 15 );

    # 4. Read (The Cast)
    # Dereferencing $void_ptr ($$void_ptr) would just return the memory address
    # as an integer, because Affix doesn't know what's inside.
    # We must CAST it to a specific type to read it.
    my $str_view = cast( $void_ptr, String );

    print $str_view;

    # 5. Cleanup
    # These are managed pointers, so Perl *would* free them when the variables
    # go out of scope. But in C, explicit is better than implicit.
    free($ptr_string);
    free($void_ptr);

=head2 How It Works

=over

=item B<1. Malloc returns Void>

    my $void_ptr = malloc( 14 );

Just like in C, C<malloc> returns a C<void*>. It represents a chunk of raw memory with no type information attached.

=item B<2. Cast adds Meaning>

    my $str_view = cast( $void_ptr, String );

Casting creates a B<new Pin> that points to the I<same memory address> but has different type metadata.

    $void_ptr  -> Address 0x1234, Type: *void
    $str_view  -> Address 0x1234, Type: *char

When you dereference C<$$str_view>, Affix sees the type is C<String> and reads the memory until the null terminator.

=item B<3. Pointer Arithmetic via memcpy>

    memcpy( $void_ptr, $ptr_string, 15 );

This is a raw memory operation. It doesn't care about types; it just moves bytes. This is extremely fast, but dangerous
if you get the length wrong. Always ensure your destination buffer is large enough to hold the source data.

=item B<4. Explicit Free>

    free($void_ptr);

Affix uses Perl's memory allocator (C<safemalloc>) for C<malloc>, C<calloc>, and C<strdup>. This means these pointers
are distinct from pointers allocated by a loaded C library (which use the system C<malloc>).

Always use Affix's C<free> for Affix-created pointers, and the library's free function for library-created pointers.

=back

=head2 Kitchen Reminders

=over

=item * B<The Void Default>

If you see a large integer when you expected data (e.g. C<2029945...>), you are dereferencing a C<Pointer[Void]>. Use
C<cast($ptr, Type)> to tell Affix how to read the data.

=item * B<Buffer Overflows>

Perl protects you from buffer overflows. Affix does not. C<memcpy> will happily write past the end of your allocation
and corrupt your program's memory. Measure twice, cut once.

=back

=head1 Chapter 9: Arrays vs. Pointers (The Sentinel)

In C, arrays and pointers are cousins. In function arguments, they are twins. Declaring C<void func(int a[])> is
exactly the same as C<void func(int *a)>.

However, in Affix, B<Types Matter>.

=over

=item * B<C<Pointer[Int]>> expects a I<Reference> to a scalar integer (memory address).

=item * B<C<Array[Int]>> expects a I<List> of integers (data).

=back

This recipe shows how to pass lists of data to C using the C<Array> type, which handles allocation and copying for you.

=head2 The Recipe

We will wrap a C function that sums a zero-terminated array of integers.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        #include <stdlib.h>

        int array_sum(const int * a) {
            int i, sum;
            if (a == NULL)
                return -1; // Error code for NULL

            // Loop until we hit a 0
            for (i = 0, sum = 0; a[i] != 0; i++)
                sum += a[i];
            return sum;
        }
    END

    # 2. Bind
    # We use Array[Int] to tell Affix: "Expect a list of numbers"
    # Affix automatically handles the C "Array Decay" (passing as pointer).
    affix $c->link, array_sum => [ Array[Int] ] => Int;

    # 3. Call

    # Pass undef -> NULL
    say "Undef: " . array_sum(undef);        # -1

    # Pass [0] -> {0} -> Sums to 0 (Immediate stop)
    say "Zero:  " . array_sum( [0] );        # 0

    # Pass List -> {1, 2, 3, 0} -> Sums to 6
    say "List:  " . array_sum( [ 1, 2, 3, 0 ] ); # 6

=head2 How It Works

=over

=item B<1. Array Marshalling>

    array_sum( [ 1, 2, 3, 0 ] );

When you define an argument as C<Array[Int]>, Affix allocates a temporary C array, copies the values from your Perl
array reference into it, and passes the B<pointer> to the C function. This matches C's array decay rules.

=item B<2. The Undef Case>

    array_sum(undef);

C allows array pointers to be NULL. Affix supports this by checking for C<undef> and passing C<NULL> to the function,
skipping the allocation entirely.

=back

=head2 Kitchen Reminders

=over

=item * B<Syntactic Sugar>

You I<could> have bound this function using C<Pointer[Int]>. If you did, you would have to manually pack a binary
string or use C<malloc> to create the buffer. C<Array[Int]> handles that boilerplate for you.

=item * B<Sentinels>

Notice we passed C<0> at the end of our list: C<[1, 2, 3, 0]>. Affix does B<not> automatically append null terminators
to numeric arrays (unlike Strings). Since our C function relies on finding a C<0> to stop the loop, we must provide it
explicitly.

=back

=head1 Chapter 10: Mutable Arrays

In C, arrays passed to functions are often used as output buffers. The function reads data from the array, modifies it
in place, and expects the caller to see the changes.

Affix supports this B<Array Write-Back> automatically.

=head2 The Recipe

We will define a C function that reverses an integer array in place.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        // Reverses array 'a' in place
        int array_reverse(int a[], int len) {
            int tmp, i;
            int ret = 0; // Sum of first half (arbitrary logic)
            for (i = 0; i < len / 2; i++) {
                ret += a[i];
                tmp = a[i];
                a[i] = a[len - i - 1];
                a[len - i - 1] = tmp;
            }
            return ret;
        }

        // Wrapper for fixed-size 10-element array
        int array_reverse10(int a[10]) {
            return array_reverse(a, 10);
        }
    END
    my $lib = $c->link;

    # 2. Bind
    # Dynamic length array
    affix $lib, array_reverse => [ Array[Int], Int ], Int;

    # Fixed length array
    affix $lib, array_reverse10 => [ Array[Int, 10] ], Int;

    # 3. Call (Fixed Size)
    my @a = ( 1 .. 10 );
    array_reverse10( \@a );
    say "@a"; # Output: 10 9 8 7 6 5 4 3 2 1

    # 4. Call (Dynamic Size)
    my $b = [ 1 .. 20 ];
    array_reverse( $b, 20 );
    say "@$b"; # Output: 20 19 ... 2 1

=head2 How It Works

=over

=item B<1. In-Place Modification>

When you pass a Perl ArrayRef to an C<Array> argument:     1. Affix allocates a temporary C array.     2. Copies your
data into it.     3. Calls the C function.     4. B<Copies the data back> from C to your Perl array.

This ensures that any changes made by the C function are reflected in your Perl variable.

=item B<2. Fixed Size Padding>

    affix ..., [ Array[Int, 10] ] ...

If you define a fixed size (e.g. 10) but pass a shorter list (e.g. C<[1, 2]>), Affix allocates the full 10 integers and
zero-fills the rest. This protects the C function from reading garbage memory if it assumes the array is 10 elements
long.

=back

=head2 Kitchen Reminders

=over

=item * B<Performance>

Copying arrays back and forth (Perl -> C -> Perl) takes time. For very large datasets where you only need to modify a
few bytes, consider using C<malloc> and C<Pointer> types to keep the data in C memory (Chapter 8).

=item * B<Reference Requirement>

You must pass a reference (C<\@a> or C<$array_ref>). Passing a list directly (e.g. C<array_reverse([1,2], ...)>) works,
but the modifications will be lost because the anonymous array reference is discarded immediately after the call.

=back

=head1 Chapter 11: Variadic Functions (printf)

Some C functions don't have a fixed number of arguments. The most famous example is C<printf>, which takes a format
string and... I<everything else>.

Affix supports variadic functions, but they require a little more care than standard functions because the C compiler
isn't there to cast types for you.

=head2 The Recipe

We will wrap the standard C library's C<snprintf>. This is safer than C<printf> because it writes to a buffer.

We also handle a common cross-platform annoyance: on Windows, this function is often named C<_snprintf>, while on
Linux/macOS it is C<snprintf>. We can normalize this using symbol aliasing.

    use v5.40;
    use Affix;

    # 1. Bind snprintf
    # Windows uses _snprintf, POSIX uses snprintf.
    # We detect the OS and bind the correct symbol to the name 'snprintf'.
    my $symbol = $^O eq 'MSWin32' ? '_snprintf' : 'snprintf';

    # Signature: int snprintf(char *str, size_t size, const char *format, ...);
    # We use '...' (or VarArgs) to indicate the variadic part.
    affix libc, [ $symbol => 'snprintf' ],
        [ Pointer[Char], Int, String, VarArgs ] => Int;

    # 2. Prepare a buffer
    # We need a place for C to write the formatted string.
    my $size = 100;
    my $buffer = "\0" x $size;

    # 3. Call with Inference
    # Affix guesses the C type based on the Perl value.
    #   "A String" -> char*
    #   123        -> int64_t
    #   12.34      -> double
    snprintf(
        $buffer, $size,
        "Name: %s, ID: %d, Score: %.2f",
        "Alice", 42, 99.9
    );

    # Clean up the null terminator and print
    $buffer =~ s/\0.*//;
    say $buffer; # "Name: Alice, ID: 42, Score: 99.90"

    # 4. Explicit Coercion
    # Sometimes inference isn't enough.
    # Here we want to print a pointer address (%p).
    # Passing a Perl integer might be interpreted as a value, not a pointer.
    # We use coerce() to force specific types.
    my $ptr = 0xDEADBEEF;

    snprintf(
        $buffer, $size,
        "Pointer address: %p",
        coerce( Pointer[Void], $ptr )
    );

    $buffer =~ s/\0.*//;
    say $buffer;

=head2 How It Works

=over

=item B<1. Symbol Aliasing>

    affix $lib, [ 'RealSymbol', 'PerlName' ], ...

Often, C libraries have messy naming conventions or platform-specific quirks (like C<_snprintf> vs C<snprintf>), or the
library has mangled symbol names. By passing an array reference as the symbol name, you tell Affix: "Find B<RealSymbol>
in the library, but create a Perl subroutine named B<PerlName>."

=item B<2. VarArgs in Signature>

    [ ..., VarArgs ]

The C<VarArgs> constant (or the string C<';'>) tells Affix: "Stop checking types here. Everything after this point is
dynamic."

=item B<3. Dynamic JIT>

When you call a variadic function, Affix looks at the arguments you provided I<at that moment>. It generates a custom,
temporary API signature on the fly (e.g., C<(char*, size_t, char*, char*, int64, double)>) and compiles a trampoline
for it.

These trampolines are cached, so calling C<snprintf> repeatedly with the same argument types is fast.

=item B<4. Coercion>

    coerce( Type, $value )

If you need to pass a C<float> (not double), a C<short>, or a C<struct> by value, the default inference won't work.
C<coerce> attaches a "Type Hint" to the value. Affix sees this hint and uses the exact type you requested.

=back

=head2 Kitchen Reminders

=over

=item * B<Format Strings>

Affix does not validate your format string (e.g. C<"%s">). If you pass an integer to a C<%s> placeholder, C<snprintf>
will try to read memory at address 123 and likely segfault.

=item * B<Sentinels>

Some variadic functions (like C<execl> or certain GUI builders) expect a C<NULL> sentinel at the end of the list. Don't
forget to pass C<undef> (or C<coerce(Pointer[Void], undef)>) if the C API requires it.

=back

=head1 Chapter 12: Callbacks (qsort)

C libraries often use "Callback functions" to delegate logic back to the user. The standard library's C<qsort> is the
classic example: it knows how to sort, but it doesn't know I<how> to compare your data. It asks you to provide a
function for that.

Affix allows you to pass a standard Perl subroutine (CodeRef) where C expects a function pointer.

=head2 The Recipe

We will sort a list of integers using the C standard library's C<qsort>.

    use v5.40;
    use Affix;

    # 1. Bind qsort
    # void qsort(void *base, size_t nmemb, size_t size,
    #            int (*compar)(const void *, const void *));
    #
    # The callback signature is defined inside the argument list.
    # Callback[ [Args...] => ReturnType ]
    affix libc, 'qsort',
        [
            Pointer[Int],
            Size_t,
            Size_t,
            Callback[ [Pointer[Int], Pointer[Int]] => Int ]
        ] => Void;

    # 2. Prepare Data
    # qsort works on a raw memory array.
    # We create a C array of integers.
    my $nums = [ 88, 56, 100, 2, 25 ];
    my $count = scalar @$nums;

    # 3. Define the Comparator
    # C passes us pointers to the two items being compared.
    # We must dereference them to get the values.
    my $compare_fn = sub ( $p_a, $p_b ) {
        my $a = $$p_a;
        my $b = $$p_b;
        return $a <=> $b;
    };

    # 4. Call
    # We pass the ArrayRef directly. Affix handles the pointer decay
    # and write-back (see Chapter 10).
    # sizeof(int) is usually 4.
    qsort( $nums, $count, 4, $compare_fn );

    say join(", ", @$nums); # 2, 25, 56, 88, 100

=head2 How It Works

=over

=item B<1. The Callback Type>

    Callback[ [Pointer[Int], Pointer[Int]] => Int ]

This tells Affix to create a B<Reverse Trampoline>. It generates a small piece of C code that looks like a standard C
function. When that C code is called by C<qsort>, it:

1. Marshals the C arguments (two pointers) into Perl variables. 2. Calls your Perl subroutine C<$compare_fn>. 3. Takes
the integer return value and passes it back to C.

=item B<2. Pointer Dereferencing>

    my $a = $$p_a;

In the callback signature, we claimed the arguments were C<Pointer[Int]>. Affix receives the raw address from C, wraps
it in a B<Pin> with the type C<Int>, and passes it to your sub. Dereferencing it reads the integer value from memory.

=back

=head2 Kitchen Reminders

=over

=item * B<Scope and Lifecycle>

The magic trampoline created for your subroutine exists only as long as the C call is running. If you pass a callback
to a C function that stores it for later use (like setting an event handler in a GUI library), you must ensure your
Perl CodeRef stays alive.

=item * B<Exceptions>

If your Perl callback dies (throws an exception), Affix catches it, issues a warning, and returns a zero/void value to
C to prevent crashing the host application. C does not understand Perl exceptions.

=back

=pod

=head1 Chapter 13: Transparent Structs

Sometimes you need to peek inside the box.

If a C API expects a struct by value, or if you want to read struct members without writing C helper functions, you can
define the struct layout in Perl.

=head2 The Recipe

We will create a simple geometry library that operates on Points and Rectangles.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C Library
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        typedef struct {
            int x, y;
        } Point;

        typedef struct {
            Point top_left;
            Point bottom_right;
            int color;
        } Rect;

        // Pass by Value
        int area(Rect r) {
            int w = r.bottom_right.x - r.top_left.x;
            int h = r.bottom_right.y - r.top_left.y;
            return w * h;
        }

        // Pass by Reference (Modify in place)
        void move_rect(Rect *r, int dx, int dy) {
            r->top_left.x += dx;
            r->top_left.y += dy;
            r->bottom_right.x += dx;
            r->bottom_right.y += dy;
        }
    END
    my $lib = $c->link;

    # 2. Define Types
    # Order matters! Defined in the same order as the C struct.
    typedef Point => Struct [
        x => Int,
        y => Int
    ];

    # We can nest types. Point() refers to the typedef above.
    typedef Rect => Struct [
        tl    => Point(),
        br    => Point(),
        color => Int
    ];

    # 3. Bind
    affix $lib, 'area',      [ Rect() ]           => Int;
    affix $lib, 'move_rect', [ Pointer[Rect()], Int, Int ] => Void;

    # 4. Use (Pass by Value)
    # We represent the struct as a HashRef.
    my $r = {
        tl    => { x => 0,  y => 0 },
        br    => { x => 10, y => 20 },
        color => 0xFF00FF
    };

    say "Area: " . area($r); # 200

    # 5. Use (Pass by Reference)
    # We pass a reference to the hash.
    # Affix updates the hash members after the call.
    move_rect( $r, 5, 5 );

    say "New TL: $r->{tl}{x}, $r->{tl}{y}"; # 5, 5

=head2 How It Works

=over

=item B<1. Structural Typing>

    typedef Point => Struct [ x => Int, y => Int ];

Affix calculates the memory layout (padding, alignment, size) of the struct matching the platform's C ABI.

=item B<2. HashRef Marshalling>

When you pass a HashRef to a C<Struct> argument, Affix packs the hash values into a temporary C memory block. When the
call returns, if you passed a reference (step 5), Affix unpacks the C memory back into your HashRef, updating any
changed values.

=item B<3. Nesting>

Structs can contain other Structs, Arrays, and Pointers. Affix handles the recursive packing and unpacking
automatically.

=back

=head2 Kitchen Reminders

=over

=item * B<Performance>

Marshalling a deep HashRef into a C struct (and back) involves copying data. For high-performance scenarios (like
processing millions of points), use C<calloc> to allocate the struct in C memory once, and pass the pointer around.

=item * B<Missing Keys>

If your HashRef is missing a key defined in the Struct, Affix assumes 0 (or NULL).

=back

=head1 Chapter 14: Smart Enums (Dualvars)

C headers are full of C<enum> definitions. To the C compiler, these are just integers. To the programmer, they have
semantic meaning.

When binding these functions to Perl, passing magic numbers (like C<0>, C<1>, C<2>) makes your code unreadable. Affix
solves this by allowing you to define Enums that generate **Perl Constants** and return **Dualvars**.

=head2 The Recipe

We will wrap a hypothetical state machine library.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        typedef enum {
            STATE_IDLE      = 0,
            STATE_RUNNING   = 1,
            STATE_PAUSED    = 2,
            STATE_ERROR     = 99,
            // Bitmasks
            FLAG_READ       = 1 << 0, // 1
            FLAG_WRITE      = 1 << 1  // 2
        } MachineState;

        int set_state(MachineState s) {
            return s; // Returns the new state
        }
    END
    my $lib = $c->link;

    # 2. Define the Enum
    # We can use:
    #   'NAME'            -> Auto-increments
    #   [ NAME => Value ] -> Explicit value
    #   [ NAME => 'Expr'] -> C-style expression strings
    typedef State => Enum [
        [ STATE_IDLE    => 0 ],
        'STATE_RUNNING',              # Auto-set to 1
        'STATE_PAUSED',               # Auto-set to 2
        [ STATE_ERROR   => 99 ],
        [ FLAG_READ     => '1 << 0' ],
        [ FLAG_WRITE    => '1 << 1' ],
        [ FLAG_RDWR     => 'FLAG_READ | FLAG_WRITE' ]
    ];

    # 3. Bind
    # We use the typedef alias '@State'
    affix $lib, 'set_state', [ State() ] => State();

    # 4. Use Constants (Input)
    # typedef installs these constants into your package.
    set_state( STATE_RUNNING );
    set_state( FLAG_RDWR );

    # 5. Use Dualvars (Output)
    # The return value behaves like a number AND a string.
    my $current = set_state( STATE_PAUSED );

    if ( $current == 2 ) {
        say "Numeric check passed.";
    }

    if ( $current eq 'STATE_PAUSED' ) {
        say "String check passed.";
    }

    # Debugging is free
    say "Current State: $current"; # Prints "Current State: STATE_PAUSED"

=head2 How It Works

=over

=item B<1. Constants Generation>

When you call C<typedef ... Enum [...]>, Affix calculates the integer value of every element in the list. It then
installs a constant subroutine (e.g., C<sub STATE_IDLE () { 0 }>) into your current package. This allows you to use the
names directly in your Perl code.

=item B<2. Expression Parsing>

Affix includes a small expression parser. This allows you to copy-paste definitions from C headers‚Äîlike bit shifts
(C<<< 1 << 4 >>>) or combinations (C<FLAG_A | FLAG_B>)‚Äîdirectly into your Affix definition without manually
calculating the result.

=item B<3. Dualvars>

When a C function returns a value defined as an C<Enum> type, Affix looks up the integer in the definition map. If
found, it returns a Scalar with B<both> slots filled:     * IV (Integer Value): 2     * PV (String Value):
"STATE_PAUSED"

This allows you to write readable code (C<eq 'STATE_...'>) while maintaining high performance for numeric comparisons.

=back

=head2 Kitchen Reminders

=over

=item * B<Unknown Values>

If the C library returns an integer that you didn't define in your Enum list (e.g., a new error code added in a library
update), Affix returns the integer as a string (e.g., value C<100> becomes string C<"100">). It does not crash.

=item * B<Scope>

The constants are installed into the package where C<typedef> is called. If you put your Affix setup in a utility
module (e.g., C<MyApp::Lib>), callers will need to import those constants or refer to them fully qualified
(C<MyApp::Lib::STATE_IDLE>).

=back

=head1 Chapter 15: SIMD Vectors (Number Crunching)

Standard Perl scalars are designed for flexibility, not raw math throughput. When you need to process millions of
coordinates, pixels, or audio samples, you want B<SIMD> (Single Instruction, Multiple Data).

Affix makes SIMD vectors (like C<__m128>, C<__m256>, C<float32x4_t>) first-class citizens.

=head2 The Recipe

We will wrap a hypothetical 3D math library that uses 128-bit vectors (4 floats).

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C Library
    # We use GCC/Clang vector extensions for this example.
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        #if defined(__GNUC__) || defined(__clang__)
            typedef float v4f __attribute__((vector_size(16)));

            // Add two vectors
            v4f add_vecs(v4f a, v4f b) {
                return a + b;
            }

            // Scale a vector by a scalar
            v4f scale_vec(v4f v, float s) {
                return v * s;
            }

            // Dot product (returns scalar)
            float dot_vec(v4f a, v4f b) {
                v4f res = a * b;
                return res[0] + res[1] + res[2] + res[3];
            }
        #endif
    END
    my $lib = $c->link;

    # 2. Bind
    # We define a generic "Vec4" type: v[4:float]
    typedef Vec4 => Vector[ 4, Float ];

    affix $lib, 'add_vecs',  [ Vec4(), Vec4() ] => Vec4();
    affix $lib, 'scale_vec', [ Vec4(), Float ]  => Vec4();
    affix $lib, 'dot_vec',   [ Vec4(), Vec4() ] => Float;

    # 3. Use (Packed Strings - The Fast Way)
    # Pack 4 floats into a 16-byte string
    my $v1 = pack( 'f4', 1.0, 2.0, 3.0, 4.0 );
    my $v2 = pack( 'f4', 5.0, 6.0, 7.0, 8.0 );

    # Add
    my $sum_ref = add_vecs( $v1, $v2 );

    # Results come back as ArrayRefs by default (for convenience)
    say "Sum: " . join(", ", @$sum_ref); # 6, 8, 10, 12

    # 4. Use (ArrayRefs - The Convenient Way)
    # You can also pass ArrayRefs directly. Affix handles the packing.
    my $scaled_ref = scale_vec( [1.0, 1.0, 1.0, 1.0], 0.5 );
    say "Scaled: " . join(", ", @$scaled_ref); # 0.5, 0.5, 0.5, 0.5

    # 5. Dot Product
    my $dot = dot_vec( $v1, $v2 );
    say "Dot Product: $dot"; # 1*5 + 2*6 + 3*7 + 4*8 = 70

=head2 How It Works

=over

=item B<1. First-Class Types>

    Vector[ 4, Float ]

Affix understands that this is not just an array, but a specific machine type (128-bit register). On x64, this maps to
C<__m128> and is passed in SSE registers (XMM0, etc.). On ARM64, it maps to NEON registers (V0, etc.).

=item B<2. Packed String Input>

    my $v1 = pack( 'f4', ... );

This is the most efficient way to work. You are creating the raw binary layout of the vector in a Perl scalar. Affix
simply passes the pointer to this data directly to the C function (or loads it into a register). This avoids the
overhead of iterating over a Perl array and converting individual values.

=item B<3. ArrayRef Output>

By default, Affix unpacks returned vectors into a Perl ArrayRef (e.g., C<[x, y, z, w]>). This is convenient for
debugging or light math.

=back

=head2 Kitchen Reminders

=over

=item * B<Alignment>

SIMD instructions are picky about alignment. When you use C<pack>, Perl usually handles the string buffer allocation,
but it doesn't guarantee 16-byte alignment. Affix handles the move to the register safely. If you use C<malloc> to
store vectors for C functions, be sure to use an aligned allocation if the C library requires it.

=item * B<Aliases>

Affix exports aliases for common SIMD types if you import C<:types>:

=over

=item C<M128>  -> C<Vector[4, Float]>

=item C<M128d> -> C<Vector[2, Double]>

=item C<M256>  -> C<Vector[8, Float]>  (AVX)

=back

=back

=head1 Chapter 16: Function Pointers in Structs (Virtual Tables)

In C, Object-Oriented Programming is often simulated using structs containing function pointers. This pattern is often
called a "VTable" (Virtual Method Table). It allows a library to call different implementations of a function depending
on the object it is holding.

Affix allows you to populate these fields with Perl subroutines, effectively creating a Perl class that C can call
into.

=head2 The Recipe

We will wrap a hypothetical "Plugin" system. The C library expects a struct containing handlers for `init` and
`process`.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile C Library
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        typedef struct {
            const char* name;
            int (*init)(void);
            void (*process)(const char* data);
        } Plugin;

        void run_plugin(Plugin* p, const char* data) {
            if (p->init()) {
                p->process(data);
            }
        }
    END
    my $lib = $c->link;

    # 2. Define Types
    # The struct fields must include the Callback signature.
    typedef Plugin => Struct [
        name    => String,
        init    => Callback[ [] => Int ],
        process => Callback[ [String] => Void ]
    ];

    # 3. Bind
    affix $lib, 'run_plugin', [ Pointer[Plugin()], String ] => Void;

    # 4. Create the Perl "Object"
    # We use a HashRef to represent the struct.
    # The callback fields are populated with anonymous subs.
    my $my_plugin = {
        name    => "PerlPlugin v1.0",

        init    => sub {
            say "Initializing Perl Plugin...";
            return 1; # Success
        },

        process => sub ($data) {
            say "Processing data in Perl: $data";
        }
    };

    # 5. Call C
    # We pass the reference to our hash. Affix packs it into the C struct,
    # creating trampolines for the subroutines automatically.
    run_plugin( $my_plugin, "Some Input Data" );

=head2 How It Works

=over

=item B<1. Nested Callbacks>

    init => Callback[ [] => Int ]

When you define a struct member as a C<Callback>, Affix expects a Perl CodeRef (sub) in that hash field.

=item B<2. Auto-Trampolining>

When you pass the HashRef C<$my_plugin> to the C function, Affix: 1. Allocates the C struct. 2. Copies the string
"PerlPlugin v1.0". 3. Generates B<Reverse Trampolines> for the C<init> and C<process> subs. 4. Stores the function
pointers to those trampolines in the struct.

=item B<3. Execution>

When C calls C<p->process(data)>, it hits the trampoline, which calls your Perl sub.

=back

=head2 Kitchen Reminders

=over

=item * B<Lifetime Management>

The trampolines generated for struct members exist only for the duration of the call to C<run_plugin>. If the C library
stores this struct pointer globally and tries to call the callbacks I<after> C<run_plugin> returns, the program will
crash.

If you need persistent callbacks, you must manually allocate the struct using C<calloc> and assigning the fields,
ensuring the Perl variables stay in scope.

=back

=head1 Chapter 17: Direct Marshalling (Benchmarks)

Speed. Sometimes you need a lot of it.

Standard Affix calls involve a "Marshalling" phase: Perl values are converted to C values, stored in a buffer, passed
to the JIT trampoline, and then passed to the C function. This is flexible, but adds overhead.

B<Direct Marshalling> removes the middleman. Affix generates a specialized JIT trampoline that knows how to read your
Perl variables directly.

=head2 The Recipe

We will compare the standard C<wrap> against C<direct_wrap> using a simple addition function.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use Benchmark qw[cmpthese];

    # 1. Compile
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        int add(int a, int b) { return a + b; }
    END
    my $lib = $c->link;

    # 2. Standard Bind
    my $std_add = wrap $lib, 'add', [Int, Int] => Int;

    # 3. Direct Bind
    # The syntax is identical, just a different function name.
    my $fast_add = direct_wrap $lib, 'add', [Int, Int] => Int;

    # 4. Benchmark
    my $x = 10;
    my $y = 20;

    cmpthese( -5, {
        Standard => sub { $std_add->($x, $y) },
        Direct   => sub { $fast_add->($x, $y) }
    });

=head2 The Results

On a typical machine, Direct Marshalling can be faster for simple primitives.

                   Rate Standard   Direct
    Standard 27006813/s       --      -2%
    Direct   27626341/s       2%       --

The difference between the two grows as the number of parameters grows.

=head2 How It Works

=over

=item * B<Standard Trampoline>

    Perl Stack -> Argument Buffer -> C Trampoline -> C Function

The trampoline is generic. It expects arguments to be laid out in a specific C array format.

=item * B<Direct Trampoline>

    Perl Stack -> C Function (via custom JIT)

Affix generates machine code that calls into the Perl API (e.g. C<SvIV>) directly to fetch values from the Perl stack,
puts them into CPU registers, and jumps straight to the target function.

=back

=head2 Kitchen Reminders

=over

=item * B<Experimental>

This feature is currently marked as B<Experimental> because it is not as feature complete as the mainline affix and
wrap functions. It supports primitives (Int, Float, Pointer) robustly, but complex aggregates (Structs by value) may
fallback to standard marshalling or behave unexpectedly in edge cases.

=item * B<Restrictions>

Direct marshalling relies on knowing exact types at compile time. It is less forgiving of type mismatches (e.g. passing
an Object where an Int is expected) than the standard path, which often attempts coercion.

=back

=head1 Chapter 18: Troubleshooting & Debugging

When Perl goes wrong, you get an error message. When C goes wrong, you get a Segmentation Fault, a frozen terminal, or
data corruption that only shows up three hours later.

This chapter provides a survival kit for when things go bump in the night.

=head2 The Bug: The Vanishing Callback

A common source of crashes in FFI is the **Scope Mismatch**. Perl relies on Reference Counting. C relies on you knowing
what you are doing.

    # 1. C Library (Event System)
    # void register_handler(void (*cb)(void));
    # void trigger_event();

    # 2. Perl Binding
    affix $lib, 'register_handler', [ Callback[ []=>Void ] ] => Void;
    affix $lib, 'trigger_event',    [] => Void;

    # 3. The Buggy Code
    sub setup {
        # We pass an anonymous subroutine.
        # Affix creates a trampoline for it.
        register_handler( sub { say "Event!" } );

        # END OF SCOPE
        # The anonymous sub has refcount 0. Perl frees it.
        # The trampoline is destroyed.
    }

    setup();

    # ... later ...
    trigger_event(); # SEGFAULT! C jumps to freed memory.

=head2 The Fix

You must ensure the Perl CodeRef lives as long as the C library needs it.

    my $KEEP_ALIVE; # Global or Object-level storage

    sub setup {
        $KEEP_ALIVE = sub { say "Event!" };
        register_handler( $KEEP_ALIVE );
    }

    # ...
    trigger_event(); # Works!

=head2 The Debugging Toolbox

Affix provides tools to inspect raw memory and internal states.

=head3 1. C<Affix::dump( $ptr, $bytes )>

If you suspect struct alignment issues or garbage data, look at the raw bytes.

    my $ptr = malloc(16);
    # ... C writes to ptr ...

    # Dump 16 bytes to STDOUT in Hex/ASCII format
    Affix::dump($ptr, 16);

=head3 2. C<address( $ptr )> & C<is_null( $ptr )>

Sanity check your pointers. A pointer value of C<0> (NULL) or C<0xFFFFFF...> (Uninitialized memory) is a smoking gun.

    my $ptr = some_c_function();
    say sprintf("Pointer address: 0x%X", address($ptr));

=head3 3. C<get_system_error()>

If a C function returns C<-1> or C<NULL> to indicate failure, it usually sets a system error code (errno/GetLastError).

    if ( some_call() < 0 ) {
        die "C Error: " . get_system_error();
    }

=head3 4. C<sv_dump( $scalar )>

Debugging the Perl side. If Affix refuses to accept a variable, checking its internal flags (Integer vs String,
Read-only status) often reveals why.

    my $val = 10;
    sv_dump($val);
    # flags=IOK,pIOK... (Good, it's a number)

=head2 Common Pitfalls

=over

=item * B<Writing to Strings>

C<String> arguments (C<const char*>) are read-only copies. If the C function modifies the string in-place, you MUST use
C<Pointer[Char]> and pass a mutable scalar.

=item * B<Struct Padding>

C compilers insert padding bytes to align members. If your Perl C<Struct[...]> definition doesn't match the C
compiler's packing rules, fields will be read from the wrong offsets. Use C<dump()> to verify alignment.

=item * B<VarArg Types>

Passing a Perl float to a variadic function? It promotes to C<double>. Passing an Int? It promotes to C<int64_t>. If
the C function expects a 32-bit int, use C<coerce(Int32, $val)>.

=back


=head1 Chapter 19: Performance Profiling

"Is it faster?"

This is the most common question when moving code to C. The answer is usually "Yes, but..."

There is a fixed cost to crossing the boundary between Perl and C (marshalling arguments, setting up the stack, the JIT
trampoline). If your C function does very little (like adding two numbers), the overhead might outweigh the speed gain.
If your C function does heavy lifting (matrix math, cryptography, parsing), the gain is massive.

=head2 The Recipe

We will benchmark a naive Fibonacci calculation in Perl versus C to visualize the crossover point.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use Benchmark qw[cmpthese];

    # 1. Compile C Implementation
    my $c = Affix::Compiler->new( flags => { cflags => '-O3' } );    # Optimize!
    $c->add( \<<~'END', lang => 'c' );
    int fib_c(int n) {
        if (n < 2) return n;
        return fib_c(n-1) + fib_c(n-2);
    }
    END
    my $lib = $c->link;

    # Use Direct Marshalling for maximum speed on primitives
    my $fib_c = direct_wrap $lib, 'fib_c', [Int] => Int;

    # 2. Perl Implementation
    sub fib_pl($n) {
        return $n if $n < 2;
        return fib_pl( $n - 1 ) + fib_pl( $n - 2 );
    }

    # 3. Benchmark
    say "Small N (High overhead impact)";
    cmpthese(
        -2,
        {   Perl_10 => sub { fib_pl(10) },
            C_10    => sub { $fib_c->(10) }
        }
    );
    say "\nLarge N (Raw compute dominance)";
    cmpthese(
        -2,
        {   Perl_30 => sub { fib_pl(30) },
            C_30    => sub { $fib_c->(30) }
        }
    );

=head2 How It Works

=over

=item B<1. The Boundary Cost>

In the "Small N" test, Affix might only be 2x or 3x faster (or even slower if using standard `wrap`). The CPU spends
more time setting up the call than calculating.

=item B<2. The Compute Gain>

In the "Large N" test, the C code runs entirely in native machine code for millions of recursive iterations without
crossing back to Perl. You will likely see C performing B<100x to 200x faster>.

=back

=head2 Kitchen Reminders

=over

=item * B<Batching>

If you have a C function that sets a single pixel, calling it 2 million times from Perl will be slow. Instead, expose a
C function that takes an `Array[Pixel]` and updates the whole image in one call.

=item * B<Direct Marshalling>

For tight loops involving primitives, always use `direct_affix` / `direct_wrap` (see Chapter 17).

=back

=pod

=pod

=head1 Chapter 20: SIMD Performance Profiling (Benchmarks)

So, you read chapter 19 and yet, the ultimate question remains: "Is it fast?"


=head1 Chapter 19: Performance Profiling (Benchmarks)

The ultimate question: "Is it fast?"

To find out, we will benchmark Affix against the two titans of Perl performance:

=over

=item 1. B<PDL (Perl Data Language)>

The standard for high-performance numerical computing in Perl. It is heavily optimized for processing large arrays
(piddles) in C.

=item 2. B<Inline::C>

The traditional way to write C extensions. It compiles C code on the fly and links it to Perl via XS. It is generally
considered the speed limit of Perl.

=back

=head2 The Recipe

We will run two tests:

=over

=item 1. Micro-Benchmark: Call a function 500,000 times (measuring call overhead).

=item 2. Macro-Benchmark: Call a function I<once> to process 100,000 items (measuring raw throughput).

=back

    use v5.40;
    use Benchmark qw[cmpthese];
    use Affix     qw[:all];
    use Affix::Compiler;
    use PDL;
    use Inline C => Config => ( CCFLAGSEX => '-O3 -mavx' );
    use Inline C => <<~'END_XS';
    typedef float v4f __attribute__((vector_size(16)));

    // Micro: Add single vector
    SV* inline_add(SV* a_sv, SV* b_sv) {
        STRLEN len_a, len_b;
        float* a = (float*)SvPVbyte(a_sv, len_a);
        float* b = (float*)SvPVbyte(b_sv, len_b);
        if (len_a < 16 || len_b < 16) croak('Bad length');
        v4f vc = *(v4f*)a + *(v4f*)b;
        return newSVpvn((const char*)&vc, 16);
    }

    // Macro: Add arrays of vectors
    void inline_bulk(SV* a_sv, SV* b_sv, SV* out_sv, int count) {
        v4f* a = (v4f*)SvPV_nolen(a_sv);
        v4f* b = (v4f*)SvPV_nolen(b_sv);

        SvUPGRADE(out_sv, SVt_PV);
        SvGROW(out_sv, count * 16 + 1);
        SvCUR_set(out_sv, count * 16);
        v4f* out = (v4f*)SvPV_nolen(out_sv);

        for(int i=0; i<count; i++) {
            out[i] = a[i] + b[i];
        }
    }
    END_XS

    # Compile C Library for Affix
    my $c = Affix::Compiler->new( flags => { cflags => '-O3 -mavx' } );
    $c->add( \<<~'END', lang => 'c' );
    typedef float v4f __attribute__((vector_size(16)));

    v4f affix_add(v4f a, v4f b) {
        return a + b;
    }

    void affix_bulk(v4f *a, v4f *b, v4f *out, int count) {
        for(int i=0; i<count; i++) {
            out[i] = a[i] + b[i];
        }
    }
    END
    my $lib = $c->link;

    # Standard (Safe) Binding
    my $std_add  = wrap $lib, 'affix_add',  [ Vector [ 4, Float ], Vector [ 4, Float ] ] => Vector [ 4, Float ];
    my $std_bulk = wrap $lib, 'affix_bulk', [ Pointer [Void], Pointer [Void], Pointer [Void], Int ] => Void;

    # Direct (Fast) Binding
    my $dir_add  = direct_wrap $lib, 'affix_add',  [ Vector [ 4, Float ], Vector [ 4, Float ] ] => Vector [ 4, Float ];
    my $dir_bulk = direct_wrap $lib, 'affix_bulk', [ Pointer [Void], Pointer [Void], Pointer [Void], Int ] => Void;

    # Setup Data
    # A = [1, 2, 3, 4], B = [5, 6, 7, 8] -> Sum = [6, 8, 10, 12]
    my $v1      = pack( 'f4', 1, 2, 3, 4 );
    my $v2      = pack( 'f4', 5, 6, 7, 8 );
    my $p1      = pdl( [ 1, 2, 3, 4 ] );
    my $p2      = pdl( [ 5, 6, 7, 8 ] );
    my $count   = 100_000;
    my $bytes   = $count * 16;
    my $big_a   = $v1 x $count;
    my $big_b   = $v2 x $count;
    my $big_out = "\0" x $bytes;
    my $big_p1  = $p1->dummy( 1, $count )->clump(2);
    my $big_p2  = $p2->dummy( 1, $count )->clump(2);

    # Validation Helper
    sub verify_vec( $name, $got_packed ) {
        my @got = unpack( 'f4', $got_packed );
        my @exp = ( 6, 8, 10, 12 );
        for ( 0 .. 3 ) {
            if ( abs( $got[$_] - $exp[$_] ) > 0.001 ) {
                die "$name FAILED! Expected [@exp], Got [@got]";
            }
        }
    }

    # Validation Phase
    say 'Validating...';

    # 1. Micro Validation
    # For Affix Standard, result is ArrayRef by default, unless using Packed type,
    # but our binding uses Vector[] which returns ArrayRef of numbers usually.
    # Let's check what it actually returns.
    # Update: wrap/direct_wrap returning Vector[...] types usually unpack to ArrayRef.
    # But for max speed in benchmarks we often want packed strings.
    # Wait, previous chapter said "packed strings... fast path".
    # Let's adjust verification to handle ArrayRef if needed.
    sub unpack_if_ref($val) {
        return ref($val) eq 'ARRAY' ? pack( 'f4', @$val ) : $val;
    }

    # Inline::C
    my $res_inline = inline_add( $v1, $v2 );
    verify_vec( 'Inline::C (Micro)', $res_inline );

    # Affix Standard
    my $res_std = $std_add->( $v1, $v2 );
    verify_vec( 'Affix::Std (Micro)', unpack_if_ref($res_std) );

    # Affix Direct
    my $res_dir = $dir_add->( $v1, $v2 );
    verify_vec( 'Affix::Dir (Micro)', unpack_if_ref($res_dir) );

    # PDL
    my $res_pdl = $p1 + $p2;
    verify_vec( 'PDL (Micro)', pack( 'f4', $res_pdl->list ) );

    # 2. Macro Validation
    # Inline::C
    my $buf_inline = "\0" x $bytes;
    inline_bulk( $big_a, $big_b, $buf_inline, $count );
    verify_vec( 'Inline::C (Macro - First)', substr( $buf_inline, 0, 16 ) );
    verify_vec( 'Inline::C (Macro - Last)', substr( $buf_inline, -16 ) );

    # Affix Standard
    my $buf_std = "\0" x $bytes;
    $std_bulk->( \$big_a, \$big_b, \$buf_std, $count );
    verify_vec( 'Affix::Std (Macro - First)', substr( $buf_std, 0, 16 ) );
    verify_vec( 'Affix::Std (Macro - Last)', substr( $buf_std, -16 ) );

    # Affix Direct
    my $buf_dir = "\0" x $bytes;
    $dir_bulk->( \$big_a, \$big_b, \$buf_dir, $count );
    verify_vec( 'Affix::Dir (Macro - First)', substr( $buf_dir, 0, 16 ) );
    verify_vec( 'Affix::Dir (Macro - Last)', substr( $buf_dir, -16 ) );
    say 'All results valid. Starting Benchmark.';

    # Test 1: Micro-Benchmark
    say 'Micro-Benchmark (Single Vector Add)';
    cmpthese(
        -5,
        {   'PDL'        => sub { my $r = $p1 + $p2; },
            'Inline::C'  => sub { inline_add( $v1, $v2 ) },
            'Affix::Std' => sub { $std_add->( $v1, $v2 ) },
            'Affix::Dir' => sub { $dir_add->( $v1, $v2 ) }
        }
    );

    # Test 2: Macro-Benchmark
    say 'Macro-Benchmark (100k Vectors / 1.6MB)';
    cmpthese(
        -5,
        {   'PDL'        => sub { my $r = $big_p1 + $big_p2; },
            'Inline::C'  => sub { inline_bulk( $big_a, $big_b, $big_out, $count ) },
            'Affix::Std' => sub { $std_bulk->( \$big_a, \$big_b, \$big_out, $count ) },
            'Affix::Dir' => sub { $dir_bulk->( \$big_a, \$big_b, \$big_out, $count ) }
        }
    );

=head2 The Results

    Validating...
    All results valid. Starting Benchmark.
    Micro-Benchmark (Single Vector Add)
                    Rate        PDL  Inline::C Affix::Std Affix::Dir
    PDL         613754/s         --       -92%       -94%       -94%
    Inline::C  7500957/s      1122%         --       -23%       -24%
    Affix::Std 9776961/s      1493%        30%         --        -1%
    Affix::Dir 9845042/s      1504%        31%         1%         --
    Macro-Benchmark (100k Vectors / 1.6MB)
                  Rate        PDL  Inline::C Affix::Dir Affix::Std
    PDL         1569/s         --       -93%       -93%       -93%
    Inline::C  22625/s      1342%         --        -2%        -3%
    Affix::Dir 23061/s      1370%         2%         --        -1%
    Affix::Std 23265/s      1383%         3%         1%         --

=head2 Analysis

=over

=item B<1. Micro (Latency): Affix Wins>

Affix is B<31% faster> than compiled XS (`Inline::C`).

This result is remarkable. `Inline::C` compiles static C code, which is usually the speed limit. However, the XS macro
system (`SvPV`, `newSV`, etc.) adds overhead for every argument.

Affix generates a B<custom JIT trampoline> at runtime. This machine code accesses the Perl stack and CPU registers
directly, bypassing the generic argument handling of standard XS. It is effectively "Inline Assembly" for Perl.

=item B<2. Macro (Throughput): Virtual Tie>

In the bulk data test, Affix and `Inline::C` perform identically (within 1% margin of error).

This confirms that Affix has B<Zero Overhead> once the pointer is passed to C. Whether you hand-write the C loop in XS
or bind it dynamically with Affix, the processor executes the same instructions at the same speed.

=back

=head2 Why Choose Affix?

=over

=item * B<Speed:> As shown above, Affix is consistently the fastest way to bridge Perl and C for primitives and vectors.

=item * B<Simplicity:> We achieved this performance with one line of Perl (C<affix>), versus 15 lines of C macros for XS.

=item * B<Portability:> Affix requires B<no compilation> at install time. You can ship your script without a C compiler dependency (if binding to pre-compiled libraries) and still get maximum performance.

=back

=head1 Chapter 21: Benchmarks (Affix vs. The World)

The Perl ecosystem offers several ways to call C code. How does Affix stack up?

We will benchmark four approaches:

=over

=item 1. B<Inline::C>

Compiles C code into a custom XS module. This is historically the fastest way to call C from Perl, as it eliminates the
"FFI" layer entirely, but it requires a C compiler at installation time (or runtime).

=item 2. B<FFI::Platypus>

The current dominant FFI module on CPAN. It uses C<libffi> (a portable, general-purpose Foreign Function Interface
library) to handle argument shuffling.

=item 3. B<Affix (Standard)>

Our default C<wrap> mode. It performs robust type checking and safety handling before invoking our custom JIT engine.

=item 4. B<Affix (Direct)>

Our high-performance C<direct_wrap> mode. It bypasses many safety checks and intermediate buffers to call the C
function as fast as physically possible.

=back

=head2 The Recipe

We will compile a shared library performing a simple integer addition, then bind it using all three libraries.

    use v5.40;
    use Benchmark qw[cmpthese];
    use Affix     qw[:all];
    use Affix::Compiler;
    use FFI::Platypus;

    # We use Inline::C for the baseline, so we need to configure it
    use Inline C => Config => ( clean_after_build => 0, );

    # 1. Inline::C Implementation
    # Inline compiles this into XS automatically.
    use Inline C => <<~'END_XS';
        int add_xs(int a, int b) {
            return a + b;
        }
    END_XS

    # 2. Compile Library for FFI
    # We need a shared object (.so/.dll) for Affix and Platypus
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END_C', lang => 'c' );
        int add_c(int a, int b) {
            return a + b;
        }
    END_C
    my $lib = $c->link;

    # 3. FFI::Platypus Setup
    my $ffi_plat = FFI::Platypus->new( api => 2 );
    $ffi_plat->lib($lib);

    # "attach" creates an XSUB alias for speed, similar to Affix
    $ffi_plat->attach( [ add_c => 'add_platypus' ] => [ 'int', 'int' ] => 'int' );

    # 4. Affix Setup
    # Standard: Full type safety
    my $add_affix = wrap $lib, 'add_c', [ Int, Int ] => Int;

    # Direct: Speed freak mode
    my $add_direct = direct_wrap $lib, 'add_c', [ Int, Int ] => Int;

    # 5. The Race
    say "Benchmarking for 5 seconds...";
    my $x = 100;
    my $y = 200;
    cmpthese(
        -5,
        {   'Inline::C' => sub { add_xs( $x, $y ) },
            'Platypus'  => sub { add_platypus( $x, $y ) },
            'Affix'     => sub { $add_affix->( $x, $y ) },
            'Affix::D'  => sub { $add_direct->( $x, $y ) }
        }
    );

=head2 The Results

On my system, I see results similar to this:

                    Rate  Platypus Inline::C     Affix  Affix::D
    Platypus   5219492/s        --      -52%      -80%      -81%
    Inline::C 10768032/s      106%        --      -58%      -61%
    Affix     25493292/s      388%      137%        --       -8%
    Affix::D  27816884/s      433%      158%        9%        --

=head2 Analysis

=over

=item B<Affix::Direct (Affix::D)>

By generating a custom JIT trampoline that reads Perl's internal SVs directly (skipping the intermediate "marshalling"
buffer that standard FFI uses), it outperforms even hand-written XS (Inline::C) and the mainline affix function in
simple cases. It is effectively "Inline Assembly" for Perl.

=item B<Affix (Standard)>

Affix's powerful features like type checking, struct marshalling, and dynamic layout calculation means it comes out
ahead in usability. For most applications, 26 million calls per second is more than fast enough.

=item B<Inline::C>

Traditionally the fastest option. It compiles static glue code. It is extremely fast but requires a C compiler on the
target machine at installation time.

=item B<FFI::Platypus>

It uses C<libffi>, a mature and stable library. It's not a quick as Inline::C or either of the affix forms despite
C<libffi> having been optimized by thousands of engineers over decades.

=back

=head2 Summary

=over

=item * Use B<Affix (Standard)> for flexibility, safety, and complex types (Structs, Arrays) and when you need raw speed for primitives (Ints, Floats) and want to beat XS.

=item * Use B<Inline::C> if you are already comfortable writing XS macros and want static compilation.

=back

=head1 Chapter 22: File I/O (The CRT Trap)

Handling files in FFI requires understanding the **C Runtime (CRT)**.

On POSIX systems (Linux, macOS, BSD), file descriptors are global integers managed by the kernel. You can open a file
in Perl and hand the descriptor to C.

On Windows, however, file descriptors belong to a specific instance of the C Runtime DLL. If Perl uses one CRT (e.g.,
UCRT) and your library uses another (e.g., MSVCRT), they cannot share file descriptors.

To ensure your code works on all platforms, the safest approach is to let C handle the file opening.

=head2 The Recipe

We will use the standard C library to write data to a file.

    use v5.40;
    use Affix qw[:all];

    # 1. Bind libc functions
    # FILE *fdopen(int fd, const char *mode);
    # int fprintf(FILE *stream, const char *format, ...);
    # int fclose(FILE *stream);
    affix libc, 'fopen',   [ String, String ]                  => Pointer [Void];
    affix libc, 'fprintf', [ Pointer [Void], String, VarArgs ] => Int;
    affix libc, 'fclose',  [ Pointer [Void] ]                  => Int;

    # 2. Open a file in Perl
    #open(my $fh, '>', 'output.txt') or die $!;
    # 3. Bridge to C
    # Get the OS file descriptor (an integer, e.g., 3)
    #my $fd = fileno($fh);
    # Create a C FILE* from that descriptor
    # Note: 'w' must match the Perl mode ('>')
    my $c_file = fopen( 'output.txt', 'w' );
    unless ( is_null($c_file) ) {

        # 4. Write using C
        fprintf( $c_file, "Line %d: Written by %s\n", 1, "Affix" );

        # 5. Flush and Close
        # CRITICAL: We must close the C handle.
        # This will also close the underlying FD, so the Perl $fh
        # becomes unusable/closed automatically.
        fclose($c_file);
    }
    # $fh is now closed.

=head2 Advanced: Bridging Perl Handles (POSIX Only)

If you are strictly targeting Linux/macOS/BSD, you I<can> bridge a Perl filehandle to C using `fdopen`.

    # WARNING: This typically fails on Windows due to CRT mismatch.
    if ($^O ne 'MSWin32') {
        affix libc, 'fdopen', [ Int, String ]    => Pointer [Void];
        affix libc, 'fflush', [ Pointer [Void] ] => Int;
        open( my $fh, '>', 'bridge.txt' ) or die $!;
        my $fd = fileno($fh);
        warn $fd;

        # Create a C view of the Perl filehandle
        my $c_stream = fdopen( $fd, 'w' );
        fprintf( $c_stream, "Writing to Perl handle via C\n" );

        # fflush required because Perl and C buffer separately
        fflush($c_stream);

        # Do not fclose() here if you want to keep using $fh in Perl!
    }

=head2 Kitchen Reminders

=over

=item * B<Buffers>

Perl and C have separate IO buffers. If you mix writing to a file from Perl and C simultaneously, the output order will
likely be scrambled. It is best to pick one language to own the file handle.

=item * B<Permissions>

C's C<fopen> does not automatically handle Perl-style path expansion (like `~/file.txt`). Always pass absolute paths or
paths relative to the current working directory.

=back

=head1 Chapter 23: Nested Callbacks & Context

In Chapter 12, we passed a simple callback. But real-world C libraries often take a callback *and* a `void *user_data`
pointer to track context.

If the C library is old or poorly designed, it might *not* accept `user_data`, forcing you to use globals. Affix allows
you to bake the context into the callback itself using closures.

=head2 The Recipe

We will wrap a hypothetical iteration function that takes a callback but no data argument.

    use v5.40;
    use feature 'class';
    no warnings 'experimental::class';
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. C Library (No user_data support)
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        void iterate_3( void (*cb)(int) ) {
            cb(1); cb(2); cb(3);
        }
    END
    my $lib = $c->link;
    affix $lib, 'iterate_3', [ Callback [ [Int] => Void ] ] => Void;

    # 2. The Problem
    # We want to sum these numbers into a Perl object.
    # But the C function doesn't accept the object.
    class Sum {
        field $total = 0;
        method add($n) { $total += $n; }
        method get()   { $total; }
    }
    my $obj = Sum->new;

    # 3. The Closure Solution
    # We define the callback inside the scope where $obj exists.
    # Perl closes over $obj.
    my $cb = sub ($n) {
        $obj->add($n);
    };

    # 4. Execute
    iterate_3($cb);
    say "Total: " . $obj->get();    # 6

=head2 How It Works

=over

=item B<1. Closures>

When you create `sub { ... }` in Perl, it captures the surrounding lexical variables (`$obj`).

=item B<2. The Trampoline>

When you pass `$cb` to Affix, Affix generates a **Reverse Trampoline**. This is a C function pointer. When C calls it,
the trampoline invokes the *specific* Perl CodeRef, which restores the Perl environment and finds `$obj`.

To the C library, it looks like a standard function pointer. To you, it looks like magic.

=back

=head1 Chapter 24: Packaging for CPAN (Alien::Base)

You wrote a script that binds to `libgit2`. It works on your laptop. Now you want to upload it to CPAN. How do you
ensure the user has `libgit2` installed?

The Perl ecosystem solves this with the **Alien** namespace.

=head2 The Recipe

This isn't a script; it's a `Makefile.PL` strategy.

    # Makefile.PL
    use ExtUtils::MakeMaker;
    use Alien::Base::Wrapper qw( Alien::libgit2 );

    WriteMakefile(
        NAME => 'My::Git::Wrapper',
        # ...
        CONFIGURE_REQUIRES => {
            'Alien::libgit2' => 0,
        },
        PREREQ_PM => {
            'Affix'          => '1.00',
            'Alien::libgit2' => 0,
        },
    );

    # In your module: lib/My/Git/Wrapper.pm
    package My::Git::Wrapper;
    use Affix;
    use Alien::libgit2;

    # Ask Alien where the library is
    my $lib_path = Alien::libgit2->dynamic_libs;

    # Bind
    affix $lib_path, 'git_libgit2_init', [] => Int;

=head2 How It Works

=over

=item B<1. Alien::Modules>

`Alien::libgit2` (and hundreds of others) are CPAN modules dedicated to finding a C library on the system or, if
missing, downloading and compiling it from source during installation.

=item B<2. Dynamic Resolution>

`$alien->dynamic_libs` returns the absolute path to the `.so` or `.dll` file found/built by Alien. Feeding this to
Affix ensures your wrapper works on any system, regardless of where libraries are installed.

=back

=head1 Chapter 25: The Rust Bridge

Rust is excellent for writing safe, high-performance shared libraries. `Affix::Compiler` supports Rust out of the box.

=head2 The Recipe

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Write Rust
    # We use #[no_mangle] and extern "C" to expose C-compatible symbols.
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'rs' );
        #[no_mangle]
        pub extern "C" fn rust_add(a: i32, b: i32) -> i32 {
            a + b
        }
    END

    # 2. Compile
    # This invokes `rustc` and produces a .so/.dll
    my $lib = $c->link;

    # 3. Bind
    affix $lib, 'rust_add', [Int, Int] => Int;

    say rust_add(50, 50); # 100

=head2 How It Works

=over

=item B<1. The C ABI>

Rust (and Go, and Zig, and Nim) can speak the "C Calling Convention". By marking a function `extern "C"`, you tell the
Rust compiler to generate machine code compatible with standard linkers. Affix doesn't know it's calling Rust; it just
sees a binary interface.

=back

=head1 Chapter 26: Error Handling (errno)

System calls fail. In C, you check the global `errno` variable (or `GetLastError()` on Windows). In Affix, we expose
this via `get_system_error`.

=head2 The Recipe

We will try to open a file that doesn't exist.

    use v5.40;
    use Affix qw[:all];

    # fopen returns NULL on failure
    affix libc, 'fopen', [String, String] => Pointer[Void];

    my $file = fopen("non_existent_file.txt", "r");

    if (is_null($file)) {
        # get_system_error returns the numeric error code
        # In numerical context: errno
        # In string context:    strerror(errno)
        my $err = Affix::get_system_error();

        die "Could not open file: $err (${\(0+$err)})";
    }

=head2 How It Works

=over

=item B<1. Thread Local Storage>

When an FFI call returns, Affix immediately captures the system error code from the thread-local C storage and saves
it. You can retrieve it safely even if other Perl operations (like `print`) have happened in the meantime.

=item B<2. Dualvar Return>

`get_system_error()` returns a Dualvar.     * Number: `2` (ENOENT)     * String: "No such file or directory"

This makes logging errors extremely convenient.

=back

=head1 Chapter 27: Objective-C Runtime (macOS)

On macOS, system APIs are often Objective-C. ObjC is a superset of C, relying on a message-passing runtime. We can bind
to `objc_msgSend` to call methods on Cocoa objects.

=head2 The Recipe

We will create a native `NSString`.

    use v5.40;
    use Affix qw[:all];

    # 1. Load the Runtime
    my $objc = '/usr/lib/libobjc.dylib';

    # We need a few helpers to find classes and selectors (method names)
    affix $objc, 'objc_getClass',    [String] => Pointer[Void];
    affix $objc, 'sel_registerName', [String] => Pointer[Void];

    # The magic function. It is variadic.
    # id objc_msgSend(id self, SEL op, ...);
    affix $objc, 'objc_msgSend',
        [ Pointer[Void], Pointer[Void], VarArgs ] => Pointer[Void];

    # 2. Helpers
    sub msg($obj, $selector, @args) {
        state %sels;
        my $sel = $sels{$selector} //= sel_registerName($selector);
        return objc_msgSend($obj, $sel, @args);
    }

    # 3. Create a String
    # [NSString alloc]
    my $cls_NSString = objc_getClass("NSString");
    my $alloc        = msg($cls_NSString, "alloc");

    # [alloc initWithUTF8String:"Hello from macOS"]
    # We must coerce the string to Pointer[Void] or it might be treated as char*
    my $str_obj = msg($alloc, "initWithUTF8String:",
                      coerce(String, "Hello from macOS"));

    # 4. Print it (description)
    # const char* s = [[str_obj description] UTF8String];
    my $desc = msg($str_obj, "description");
    my $utf8 = msg($desc,    "UTF8String");

    # Cast raw pointer to Perl String
    say cast($utf8, String);

=head2 How It Works

This works because `objc_msgSend` is just a C function. By defining it as Variadic, Affix constructs the correct stack
frame to pass messages to the Objective-C runtime, effectively letting you write Cocoa apps in Perl.

=head1 Chapter 28: Automatic Resource Management (RAII)

Manual C<free()> is error-prone. We can use Perl's C<DESTROY> phase to automate it.

=head2 The Recipe

    package AutoPointer {
        use Affix;

        sub new {
            my ($class, $ptr) = @_;
            return bless \$ptr, $class;
        }

        sub DESTROY {
            my $self = shift;
            return if is_null($$self);

            # Call C free()
            Affix::free($$self);

            # Prevent double-free
            $$self = 0;
        }

        # Accessor to get the raw Pin
        sub ptr { ${shift()} }
    }

    # Usage
    {
        my $raw = malloc(1024);
        my $safe = AutoPointer->new($raw);

        # ... use $safe->ptr ...

    } # $safe goes out of scope -> DESTROY called -> free() called.

=head2 How It Works

Perl uses Reference Counting. When the last reference to `$safe` disappears, Perl calls `DESTROY`. By wrapping our raw
C pointer (Pin) in a blessed object, we tie the C memory lifecycle to the Perl variable's scope. This is known as
**RAII** (Resource Acquisition Is Initialization).

=head1 Chapter 28: Multithreading (Beating PDL)

Perl's threading model (ithreads) is heavy; it clones the entire interpreter for every thread. For high-performance
number crunching, this is unacceptable.

The standard solution in Perl is B<PDL> (Perl Data Language), which implements its own threading engine in C. It is
fast, robust, and the industry standard for a reason.

However, generic tools have generic overhead. With Affix, you can implement a B<purpose-built threading model> in C
that strips away all safety checks, object management, and abstraction layers, allowing you to outperform even PDL.

=head2 The Recipe

We will perform element-wise addition on two arrays of B<20 Million Floats> (approx. 80MB each). We will use 4 threads
to saturate the memory bus.

    use v5.40;
    use Benchmark qw[cmpthese];
    use Affix     qw[:all];
    use Affix::Compiler;
    use PDL;
    use Config;

    # 1. Configure PDL (The Competition)
    my $threads = 4;
    my $pdl_ok  = 0;

    # PDL threading setup
    if ( defined &PDL::set_autopthread_targ ) {
        set_autopthread_targ($threads);
        set_autopthread_size(0);    # 0 = Always thread if possible

        # Verify configuration
        if ( get_autopthread_targ() == $threads ) {
            $pdl_ok = 1;
            say "PDL Threading: Enabled ($threads threads)";
        }
        else {
            say "PDL Threading: Requested but not active (Single threaded fallback)";
        }
    }
    else {
        say "PDL Threading: Not supported by this installation";
    }

    # 2. Compile C Library (The Affix Way)
    # We use -O3 for vectorization and -pthread for threading
    my $c = Affix::Compiler->new( debug => 0, flags => { cflags => '-O3 -mavx -pthread' } );
    $c->add( \<<~'END', lang => 'c' );
    #include <stdlib.h>
    #include <pthread.h>

    typedef struct {
        float *a;
        float *b;
        float *out;
        int count;
    } Work;

    void* add_worker(void *arg) {
        Work *w = (Work*)arg;
        // Simple loop, autovectorizable by -O3 -mavx
        for(int i=0; i < w->count; i++) {
            w->out[i] = w->a[i] + w->b[i];
        }
        return NULL;
    }

    void add_mt(float *a, float *b, float *out, int count, int num_threads) {
        pthread_t *t = malloc(sizeof(pthread_t) * num_threads);
        Work *w      = malloc(sizeof(Work) * num_threads);
        int chunk    = count / num_threads;

        for(int i=0; i<num_threads; i++) {
            w[i].a = a + (i * chunk);
            w[i].b = b + (i * chunk);
            w[i].out = out + (i * chunk);
            // Give remainder to the last thread
            w[i].count = (i == num_threads-1) ? (count - i*chunk) : chunk;

            pthread_create(&t[i], NULL, add_worker, &w[i]);
        }

        for(int i=0; i<num_threads; i++) {
            pthread_join(t[i], NULL);
        }

        free(t);
        free(w);
    }
    END
    my $lib = $c->link;

    # 3. Bind
    # Direct Marshalling for minimum overhead
    my $affix_mt = wrap $lib, 'add_mt', [ Pointer [Void], Pointer [Void], Pointer [Void], Int, Int ] => Void;

    # 4. Data Setup
    # 20 Million Floats (~80MB per array, 240MB total throughput per call)
    my $count = 20_000_000;
    my $bytes = $count * 4;
    say "Allocating Data ($count floats)...";

    # Affix: Packed Strings (Raw Memory)
    my $blob    = pack( 'f*', (1.1) x $count );
    my $aff_a   = $blob;                          # Copy
    my $aff_b   = $blob;                          # Copy
    my $aff_out = "\0" x $bytes;

    # PDL: Piddles (C Arrays wrapped in Perl objects)
    # zeroes() allocates the array, += initializes it
    my $pdl_a = zeroes( float, $count );
    $pdl_a += 1.1;
    my $pdl_b = $pdl_a->copy;

    # 5. Validation
    say "Validating...";

    # Expected result: 1.1 + 1.1 = 2.2
    my $EXPECT = 2.2;

    # Check PDL
    my $res_p = $pdl_a + $pdl_b;
    my $val_p = $res_p->at(0);
    if ( abs( $val_p - $EXPECT ) > 0.001 ) {
        die "PDL Validation Failed: Expected $EXPECT, got $val_p";
    }

    # Check Affix
    $affix_mt->( \$aff_a, \$aff_b, \$aff_out, $count, $threads );
    my $val_a = unpack( 'f', substr( $aff_out, 0, 4 ) );    # Typo Fixed: $affix_out -> $aff_out
    if ( abs( $val_a - $EXPECT ) > 0.001 ) {
        die "Affix Validation Failed: Expected $EXPECT, got $val_a";
    }
    say "Validation Passed. Starting Benchmark.";

    # 6. Benchmark
    cmpthese(
        -10,
        {   'PDL' => sub {

                # PDL handles threading internals
                my $r = $pdl_a + $pdl_b;
            },
            'Affix' => sub {

                # We pass raw pointers to the C function
                $affix_mt->( \$aff_a, \$aff_b, \$aff_out, $count, $threads );
            }
        }
    );

=head2 The Results

    PDL Threading: Enabled (4 threads)
    Allocating Data (20000000 floats)...
    Validating...
    Validation Passed. Starting Benchmark.
            Rate   PDL Affix
    PDL   33.7/s    --  -47%
    Affix 63.4/s   88%    --

Of course, much of this is thanks to the OS's threading systems.

=head2 How It Works

=over

=item 1. Zero-Copy Marshalling

PDL objects ("Piddles") are complex C structs containing shape information, data flow flags, and bad-value masks.
Affix, by contrast, passes a raw pointer to your Perl scalar's string buffer directly to the C function. There is
B<zero> object creation overhead per call.

=item 2. Lightweight Concurrency

PDL's C<pthread> engine is generic; it has to calculate slice offsets, handle broadcasting, and check for data flow
dependencies for every chunk. Our custom C function does exactly one thing: integer arithmetic on pointers.

=back

=head2 When to use this?

=over

=item * Use L<PDL> for exploratory data analysis, complex matrix algebra, or when development time is more expensive than CPU time.

=item * Use Affix with threads when you have a specific, hot-loop algorithm (image processing, simulation stepping, crypto) that is the absolute bottleneck of your application.

=back























=pod

=head1 Chapter 29: Event Loops (Async C)

Modern Perl applications (Mojolicious, AnyEvent, IO::Async) rely on non-blocking Event Loops. Standard FFI calls are
**blocking**: if you call a C function that takes 5 seconds, your WebServer hangs for 5 seconds.

C libraries often solve this by spawning their own threads. The challenge is: **How does a C thread notify the Perl
event loop when it's done?**

You cannot call a Perl callback from a background C thread (it will crash the interpreter). You must use an OS-level
signaling mechanism.

=head2 The Recipe

We will create a C function that sleeps in a background thread, then signals Perl via a **Pipe**. We use `IO::Select`
to simulate an event loop watching that pipe.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use IO::Select;

    # 1. Compile C Library
    # We use pthreads to simulate a long-running background task.
    my $c = Affix::Compiler->new(flags => { cflags => '-pthread' });
    $c->add( \<<~'END', lang => 'c' );
        #include <unistd.h>
        #include <pthread.h>

        typedef struct {
            int pipe_fd;
            int work_time_ms;
        } Job;

        void* worker_thread(void *arg) {
            Job *j = (Job*)arg;

            // 1. Simulate heavy work (blocking)
            usleep(j->work_time_ms * 1000);

            // 2. Notify Perl
            // We write a single byte to the pipe.
            // This wakes up the Perl Event Loop.
            char msg = 'K';
            write(j->pipe_fd, &msg, 1);

            free(j);
            return NULL;
        }

        void start_async_work(int fd, int ms) {
            pthread_t t;
            Job *j = malloc(sizeof(Job));
            j->pipe_fd = fd;
            j->work_time_ms = ms;
            pthread_create(&t, NULL, worker_thread, j);
            pthread_detach(t); // Clean up automatically
        }
    END
    my $lib = $c->link;

    # 2. Bind
    affix $lib, 'start_async_work', [ Int, Int ] => Void;

    # We also need libc to read the pipe
    affix libc, 'read', [ Int, Pointer[Void], Size_t ] => SSize_t;

    # 3. Setup the Pipe
    # pipe() returns two handles: Reader and Writer.
    pipe(my $reader, my $writer) or die "pipe failed: $!";

    # Get the raw OS file descriptor for the WRITER to pass to C
    my $write_fd = fileno($writer);

    # 4. The Event Loop Simulation
    my $loop = IO::Select->new();
    $loop->add($reader);

    say "[Perl] Starting background C task...";
    start_async_work($write_fd, 1500); # 1.5 seconds

    say "[Perl] Doing other things while C works...";

    # 5. Non-Blocking Wait
    while (1) {
        # Check if the pipe is readable (timeout 0.2s)
        if (my @ready = $loop->can_read(0.2)) {

            # Read the signal byte
            my $buf = malloc(1, Char); # 1 byte buffer
            read(fileno($reader), $buf, 1);

            say "[Perl] Received signal from C: " . $$buf;
            last; # Done
        }

        # Simulate keeping the UI responsive
        state $dots = 0;
        print "\r[Perl] Waiting" . ("." x (++$dots % 4)) . "   ";
        STDOUT->flush;
    }

    say "\n[Perl] Finished.";

=head2 How It Works

=over

=item B<1. The Pipe>

A pipe is a kernel-level buffer. It has two ends.     * **Perl** holds the Read end.     * **C** receives the Write end
(as an integer File Descriptor).

=item B<2. Thread Safety>

Because the C thread uses `write()`, it asks the **Kernel** to put data in the buffer. It does not touch Perl's memory
or interpreter state. This is perfectly thread-safe.

=item B<3. The Event Loop>

Tools like `IO::Select` (or Mojo::IOLoop) rely on the OS function `select` or `poll`. They watch the file descriptor.
When C writes data, the descriptor becomes "Readable", waking up the Perl loop immediately.

=back

=head2 Kitchen Reminders

=over

=item * B<Keep the Writer Open>

In a real app, you might pass the same Write FD to multiple C jobs. Only close the write handle when you are shutting
down the application.

=item * B<Atomic Writes>

For simple notifications, writing 1 byte is atomic. If you need to pass complex data back from C, use the pipe to
signal "Ready", then have Perl call a C function (like `get_job_result()`) to fetch the data safely.

=back

=pod

=head1 Chapter 30: The Thread Pool (Async Callbacks)

We established in Chapter 29 that we can wake up Perl from a C thread. Now, let's use that to build a system where we
send work to C, and C calls a Perl callback when it finishes.

This requires a **Thread-Safe Queue** in C to hold completed jobs until the main Perl thread is ready to handle them.

=head2 The Recipe

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use IO::Select;
    use Socket;

    # 1. The C Thread Pool
    my $c = Affix::Compiler->new();

    # We need pthreads (POSIX) or Windows Threads
    my $flags = ( $^O eq 'MSWin32' ) ? '-lws2_32' : '-pthread';
    $c->new( flags => { ldflags => $flags, cflags => $flags } );
    $c->add( \<<~'END', lang => 'c' );
        #include <stdlib.h>
        #include <stdio.h>
        #include <stdint.h>

        // Platform Compatibility
        #ifdef _WIN32
            #include <windows.h>
            typedef HANDLE mutex_t;
            #define MUTEX_INIT(m) m = CreateMutex(NULL, FALSE, NULL)
            #define MUTEX_LOCK(m) WaitForSingleObject(m, INFINITE)
            #define MUTEX_UNLOCK(m) ReleaseMutex(m)
            #define THREAD_RET DWORD WINAPI
            #define THREAD_ARG LPVOID
            #define SLEEP(ms) Sleep(ms)
            // Dynamic load send() to avoid linker issues in recipe
            void signal_perl(size_t h) {
                typedef int (WINAPI *S)(SOCKET, const char*, int, int);
                static S f = NULL;
                if (!f) f = (S)GetProcAddress(LoadLibrary("ws2_32"), "send");
                if (f) f((SOCKET)h, "!", 1, 0);
            }
        #else
            #include <pthread.h>
            #include <unistd.h>
            typedef pthread_mutex_t mutex_t;
            #define MUTEX_INIT(m) pthread_mutex_init(&m, NULL)
            #define MUTEX_LOCK(m) pthread_mutex_lock(&m)
            #define MUTEX_UNLOCK(m) pthread_mutex_unlock(&m)
            #define THREAD_RET void*
            #define THREAD_ARG void*
            #define SLEEP(ms) usleep(ms * 1000)
            void signal_perl(size_t h) { write((int)h, "!", 1); }
        #endif

        // Data Structures

        // The Callback Signature: void cb(int result, int thread_id)
        typedef void (*callback_t)(int, int);

        typedef struct Job {
            int input;          // Data to process
            int thread_id;      // ID of the thread that processed it
            callback_t cb;      // Perl trampoline to call when done
            struct Job *next;
        } Job;

        // A simple thread-safe queue
        typedef struct {
            Job *head;
            Job *tail;
            mutex_t lock;
        } Queue;

        Queue todo;
        Queue done;
        size_t signal_handle; // Pipe/Socket to wake Perl

        void enqueue(Queue *q, Job *j) {
            MUTEX_LOCK(q->lock);
            j->next = NULL;
            if (q->tail) q->tail->next = j;
            else         q->head = j;
            q->tail = j;
            MUTEX_UNLOCK(q->lock);
        }

        Job* dequeue(Queue *q) {
            MUTEX_LOCK(q->lock);
            Job *j = q->head;
            if (j) {
                q->head = j->next;
                if (!q->head) q->tail = NULL;
            }
            MUTEX_UNLOCK(q->lock);
            return j;
        }

        // Worker Logic

        THREAD_RET worker(THREAD_ARG arg) {
            int my_id = (int)(intptr_t)arg; // ID passed at creation

            while (1) {
                Job *j = dequeue(&todo);
                if (!j) {
                    SLEEP(10); // Spin-wait for demo simplicity
                    continue;
                }

                // Do heavy work (simulate by sleeping)
                SLEEP(j->input);

                // Result calculation
                j->input     = j->input * 2;
                j->thread_id = my_id;

                // Move to Done Queue
                enqueue(&done, j);

                // Notify Perl
                signal_perl(signal_handle);
            }
            return 0;
        }

        // Exported API

        void init_pool(size_t handle, int num_threads) {
            signal_handle = handle;
            MUTEX_INIT(todo.lock);
            MUTEX_INIT(done.lock);

            for(int i=0; i<num_threads; i++) {
                // Pass loop index 'i' as thread argument
                #ifdef _WIN32
                CreateThread(NULL, 0, worker, (LPVOID)(intptr_t)i, 0, NULL);
                #else
                pthread_t t;
                pthread_create(&t, NULL, worker, (void*)(intptr_t)i);
                pthread_detach(t);
                #endif
            }
        }

        void submit_job(int duration, callback_t cb) {
            Job *j = malloc(sizeof(Job));
            j->input = duration;
            j->cb = cb;
            enqueue(&todo, j);
        }

        // Called by Perl Main Thread
        void process_results() {
            while (1) {
                Job *j = dequeue(&done);
                if (!j) break;

                // EXECUTE CALLBACK (Safe here!)
                j->cb(j->input, j->thread_id);

                free(j);
            }
        }
    END
    my $lib = $c->link;

    # 2. Bindings
    # Callback Signature: (int result, int thread_id) -> void
    typedef ResultCB => Callback [ [ Int, Int ] => Void ];
    affix $lib, 'init_pool',       [ Size_t, Int ]        => Void;
    affix $lib, 'submit_job',      [ Int,    ResultCB() ] => Void;
    affix $lib, 'process_results', [] => Void;

    # 3. Event Loop Setup
    socketpair( my $reader, my $writer, AF_UNIX, SOCK_STREAM, PF_UNSPEC ) or die;
    $writer->autoflush(1);

    # Platform-independent handle extraction
    my $os_handle = ( $^O eq 'MSWin32' ) ? do { require Win32API::File; Win32API::File::FdGetOsFHandle( fileno($writer) ) } : fileno($writer);

    # Start 4 background threads
    init_pool( $os_handle, 4 );

    # 4. Submit Work
    say "[Main] Submitting tasks...";

    # We must keep references to callbacks to prevent premature destruction!
    my @keep_alive;

    # Submit varied durations to ensure different threads pick them up
    for my $ms ( 100, 500, 200, 1000, 150 ) {
        my $cb = sub ( $res, $tid ) {
            say "[Main] Task finished! Result: $res (Processed by Thread $tid)";
        };
        push @keep_alive, $cb;    # Keep alive
        submit_job( $ms, $cb );
    }

    # 5. The Loop
    my $loop = IO::Select->new($reader);
    say "[Main] Entering Event Loop...";
    my $active = 5;
    while ( $active > 0 ) {

        # Wait for signal (blocking efficiently)
        if ( $loop->can_read ) {

            # Clear the signal pipe
            my $buf;
            sysread( $reader, $buf, 1024 );

            # Run C->Perl callbacks
            process_results();
            $active--;
        }
    }
    say "[Main] All done.";

Example output looks like this:

    [Main] Submitting tasks...
    [Main] Entering Event Loop...
    [Main] Task finished! Result: 200 (Processed by Thread 3)
    [Main] Task finished! Result: 400 (Processed by Thread 0)
    [Main] Task finished! Result: 300 (Processed by Thread 3)
    [Main] Task finished! Result: 1000 (Processed by Thread 2)
    [Main] Task finished! Result: 2000 (Processed by Thread 1)
    [Main] All done.

=head2 How It Works

=over

=item B<1. Submission>

C<submit_job> allocates a C<Job> struct containing the input data and the **Perl Callback Pointer**. It pushes this to
the C<todo> queue.

=item B<2. Execution (C Thread)>

A worker thread (identified by an ID from 0 to 3) wakes up, pops the job, performs the "heavy" calculation, records its
Thread ID into the job struct, and pushes the job to the C<done> queue.

=item B<3. Signaling>

The worker thread writes a byte to the socket. This wakes up the Perl script which is blocked on C<IO::Select>.

=item B<4. Dispatch (Perl Thread)>

Perl calls C<process_results()>. This C function runs **on the main thread**. It pops the completed job and invokes the
stored function pointer:

    j->cb(j->input, j->thread_id);

=item B<5. Safety>

Because C<process_results> runs on the main thread, it is perfectly safe for the C code to call into the Perl
interpreter via the trampoline.

=back

=head2 Kitchen Reminders

=over

=item * B<Callback Lifetimes>

You **must** keep the Perl CodeRef alive (referenced) until the callback has fired. If C<$cb> goes out of scope in Perl
while the C thread is working, the trampoline will be destroyed, and C<process_results> will crash when it tries to
call it.

=back

=head1 Chapter 31: Hacking C++ V-Tables (The Hard Way)

In Chapter 6, we wrapped C++ classes using C<extern "C"> helper functions. That is the "Correct Way."

But what if you are stuck with a pre-compiled C++ library and can't recompile it? You have an object pointer, but no C
functions to pass it to.

To call a method, we must act like a C++ compiler: manually look up the **Virtual Method Table (vtable)** and call the
function pointer directly.

=head2 The Recipe

We will create a C++ class, then write a Perl script that "scans" the object to find and call its methods.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use Config;

    # Compile C++ Library
    # We define a class with virtual methods.
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'cpp' );
        #include <stdio.h>

        class Calculator {
        public:
            // Explicit virtual destructor
            // (Often occupies vtable slots 0 & 1 on GCC/Clang)
            virtual ~Calculator() {}

            // Target Methods
            virtual void say_hello(const char* name) {
                printf("Hello, %s!\n", name);
            }

            virtual int add(int a, int b) {
                return a + b;
            }
        };

        extern "C" Calculator* new_calc() {
            return new Calculator();
        }
    END
    my $lib = $c->link;

    # 2. Get the Object
    affix $lib, 'new_calc', [] => Pointer [Void];
    my $this = new_calc();

    # Find the VTable
    # The first 8 bytes (on 64-bit) of a C++ object are usually the vptr.
    # Structure: $this -> [ vptr ] -> [ func0, func1, func2 ... ]
    # Cast $this to a Pointer to a Size_t (Pointer-sized integer).
    # This allows us to read the address stored in the first 8 bytes.
    my $vptr_ref = cast( $this, Pointer [Size_t] );

    # Dereference to get the address of the vtable array.
    my $vtable_addr = $$vptr_ref;
    say sprintf( "Object: 0x%X", address($this) );
    say sprintf( "VTable: 0x%X", $vtable_addr );

    # Scan the VTable
    # We interpret the vtable as an array of 5 pointers (Size_t).
    my $slots_pin = cast( $vtable_addr, Array [ Size_t, 5 ] );
    my $addrs     = $$slots_pin;

    # Dump the slots to find our functions.
    # Code pointers will look like valid memory addresses.
    # Slots 0/1 are often destructors or RTTI info.
    for my $i ( 0 .. 4 ) {
        say sprintf( "Slot [%d]: 0x%X", $i, $addrs->[$i] );
    }

    # Heuristic:
    # GCC/Clang (Itanium ABI): Slots 0,1 are dtors. Methods start at 2.
    # MSVC (Windows ABI): Methods usually start at 0 or 1.
    my ( $idx_hello, $idx_add ) = ( 2, 3 );

    # Simple detection for MSVC
    if ( $^O eq 'MSWin32' && $Config{cc} =~ /cl/i ) {
        ( $idx_hello, $idx_add ) = ( 0, 1 );
    }
    my $addr_hello = $addrs->[$idx_hello];
    my $addr_add   = $addrs->[$idx_add];

    # Bind and Call
    # wrap() can take a raw integer address instead of a library handle.
    #
    # CRITICAL: C++ methods pass 'this' as the hidden first argument!
    # We must include Pointer[Void] at the start of the signature.
    if ( $addr_hello && $addr_add ) {
        my $say_hello = wrap( $addr_hello, [ Pointer [Void], String ] => Void );
        my $add       = wrap( $addr_add,   [ Pointer [Void], Int, Int ] => Int );

        # Execute
        $say_hello->( $this, "Perl Hacker" );
        say "10 + 20 = " . $add->( $this, 10, 20 );
    }
    else {
        warn "Could not resolve function addresses.";
    }

=head2 How It Works

=over

=item B<1. The Memory Layout>

    $this (0x1000)
    +-----------+
    | vptr      | ------> vtable (0x5000)
    +-----------+         +--------------------------+
    | member... |         | [0] Destructor           |
                          | [1] Destructor (Deleting)|
                          | [2] say_hello()   <-- TARGET
                          | [3] add()         <-- TARGET
                          +--------------------------+

=item B<2. Double Indirection>

To get the function address, we must dereference twice:     1. Read memory at C<$this> to get C<$vtable_addr>.     2.
Read memory at C<$vtable_addr + offset> to get the function address.

We achieve this in Affix by casting C<$this> to C<Pointer[Size_t]> to read the pointer-sized integer at that location.

=item B<3. Wrapping Raw Pointers>

    my $sub = wrap( $address, [Args] => Ret );

The C<wrap> function usually takes a library handle. However, if you pass a raw integer address (or a Pin) as the first
argument, Affix treats it as the function address itself. This converts the raw vtable entry into a callable Perl
subroutine.

=back

=head2 Kitchen Reminders

=over

=item * B<Fragility>

This relies on the **Itanium C++ ABI** (Linux/macOS/MinGW) or the **MSVC ABI** (Visual Studio). The layout changes if
you use **Multiple Inheritance** or **Virtual Inheritance**. This recipe works best for simple classes or COM-style
interfaces (which use pure virtual classes).

=item * B<The 'this' Argument>

C++ methods are just C functions with a hidden first argument (`this`). When binding manually, you must include this
argument in the signature (`Pointer[Void]`) and pass the object instance every time you call the method.

=back

=head1 Chapter 32: The Rust Bridge

Perl is great for glue. Rust is great for logic.

Historically, binding Rust to Perl required complex XS modules or specific Rust crates (`perl-xs`). With Affix, you
treat Rust just like C. By using standard ABI hooks (`extern "C"`), we can compile and run Rust code dynamically
without leaving the Perl script.

=head2 The Recipe

We will define a simple Rust library that operates on a Struct.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile Rust
    # Affix::Compiler detects 'rs' and invokes `rustc`.
    my $c = Affix::Compiler->new();

    # We check if rustc is available before running
    try { $c->add( \<<~'END', lang => 'rs' ) }
    // We must define the struct layout to match C
    #[repr(C)]
    pub struct Point {
        x: i32,
        y: i32,
    }

    // #[no_mangle] keeps the symbol name "add_points"
    // extern "C" ensures the ABI uses standard registers
    #[no_mangle]
    pub extern "C" fn add_points(a: Point, b: Point) -> Point {
        Point {
            x: a.x + b.x,
            y: a.y + b.y
        }
    }

    // Example of passing a string (pointer)
    #[no_mangle]
    pub extern "C" fn hello_rust(name: *const i8) {
        use std::ffi::CStr;
        let c_str = unsafe { CStr::from_ptr(name) };
        if let Ok(s) = c_str.to_str() {
            println!("Hello, {} from Rust!", s);
        }
    }
    END
    catch ($err) {
        warn "$err\nSkipping execution.\n";
        exit 0;
    }
    my $lib = $c->link;

    # 2. Define Types
    typedef Point => Struct [ x => Int, y => Int ];

    # 3. Bind
    # We treat Rust structs exactly like C structs.
    affix $lib, 'add_points', [ Point(), Point() ] => Point();
    affix $lib, 'hello_rust', [String]             => Void;

    # 4. Execute
    my $p1 = { x => 10, y => 20 };
    my $p2 = { x => 5,  y => 5 };

    # Pass by value
    my $p3 = add_points( $p1, $p2 );
    say "Result: $p3->{x}, $p3->{y}";    # 15, 25

    # Pass string
    hello_rust("Perl");

=head2 How It Works

=over

=item B<1. C<#[repr(C)]>>

Rust creates its own memory layout for structs by default, which may not match C (or Affix). Adding this attribute
forces the compiler to lay out the struct exactly like a C struct, ensuring Affix can read the fields C<x> and C<y>
correctly.

=item B<2. C<#[no_mangle]> and C<extern "C">>

Just like C++, Rust mangles function names (e.g., `_ZN7example3add17h...`).

=over

=item * C<#[no_mangle]> turns off name mangling.

=item * C<extern "C"> sets the calling convention to the system standard (cdecl/stdcall/SystemV).

=back

=item B<3. Pointers and Unsafe>

When accepting pointers from Perl (like the string in `hello_rust`), Rust requires an `unsafe` block to dereference
them. Affix handles the memory management of the string buffer; Rust just reads it.

=back

=head2 Kitchen Reminders

=over

=item * B<Panics>

If your Rust code panics (crashes), it may unwind the stack across the FFI boundary, which is undefined behavior and
will likely abort the Perl process. Always catch panics inside your Rust `extern "C"` boundary if you want the Perl
script to survive.

=item * B<Dependencies>

C<Affix::Compiler> compiles a single file using `rustc` by default. If you need complex dependencies (like `serde` or
`tokio`), you should build your library using `cargo` separately and load the resulting `.dll` / `.so` using
`load_library`.

=back

=head1 Chapter 33: Assembly & CPU Intrinsics

C is a "portable assembly," but sometimes you need the real thing.

If you need to read the CPU Time Stamp Counter (RDTSC) for nanosecond-precision benchmarking, or access specific
processor flags, you can write raw assembly and call it from Perl.

=head2 The Recipe

We will implement a function to read the CPU cycle count (RDTSC) on x86-64 Linux/Unix systems.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Write Assembly
    # We use AT&T syntax (standard for GCC/Clang on Unix).
    # This file (.s) will be passed to the assembler.
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 's' );
        .text
        .global get_ticks

        get_ticks:
            # rdtsc puts 32 bits in EDX (high) and 32 bits in EAX (low)
            rdtsc

            # We need to pack them into a single 64-bit register (RAX)
            # Shift RDX left by 32 bits
            shl $32, %rdx

            # Combine RDX and RAX
            or %rdx, %rax

            # Return value is in RAX
            ret
    END

    # 2. Link
    # Note: On macOS, symbols need a leading underscore ('_get_ticks').
    my $lib = $c->link;

    # 3. Bind
    # The function takes no args and returns a 64-bit unsigned integer.
    affix $lib, 'get_ticks', [] => UInt64;

    # 4. Benchmark
    say "Measuring CPU cycles for a Perl operation...";

    my $start = get_ticks();

    # Do some work
    my $x = 0;
    for (1..1000) { $x += $_ }

    my $end = get_ticks();

    say "Start: $start";
    say "End:   $end";
    say "Diff:  " . ($end - $start) . " cycles";

=head2 How It Works

=over 4

=item B<1. The Assembler>

When you pass C<lang =E<gt> 's'>, C<Affix::Compiler> invokes the system assembler (usually C<as> or C<gcc>). It
compiles the raw instructions into machine code.

=item B<2. The ABI>

You must respect the Calling Convention of your platform (System V AMD64 in this example).     *   Arguments arrive in
C<RDI, RSI, RDX...>     *   Return values go in C<RAX>.     *   You must preserve "callee-saved" registers if you use
them.

Since C<rdtsc> only clobbers C<RAX> and C<RDX> (which are volatile), we don't need to save anything.

=back

=head2 Kitchen Reminders

=over 4

=item * B<Architecture Specific>

Assembly is B<not portable>. This code will crash on ARM64 (Raspberry Pi, Apple Silicon) or 32-bit systems. You must
detect C<$Config{archname}> and provide different assembly implementations for different CPUs.

=item * B<Name Mangling>

On macOS (and some 32-bit systems), C functions have a leading underscore in the symbol table. You might need to export
C<_get_ticks> in assembly to be found as C<get_ticks> by Affix.

=back

=head1 Chapter 34: Fortran (Scientific Computing)

If you are doing heavy scientific computing, you will eventually encounter Fortran (BLAS, LAPACK).

Binding Fortran is tricky because: 1.  Function names often have trailing underscores (C<dgemm_>). 2.  B<Everything> is
passed by reference (pointers). 3.  Strings/Arrays often have hidden length arguments added to the end of the argument
list.

=head2 The Recipe

We will compile a simple Fortran subroutine that adds two numbers and modifies a string.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile Fortran
    # Requires gfortran installed
    my $c = Affix::Compiler->new();
    try {
        $c->add( \<<~'END', lang => 'f' );
              subroutine f_add(a, b, res)
                  integer, intent(in) :: a, b
                  integer, intent(out) :: res
                  res = a + b
              end subroutine

              ! Prints a message
              subroutine f_hello(msg)
                  character(len=*), intent(in) :: msg
                  print *, "Fortran says: ", msg
              end subroutine
        END
    }
    catch ($err) { warn $err; exit 0; }
    my $lib = $c->link;

    # 2. Bind
    # Fortran compilers (gfortran) lowercase names and append an underscore.
    # f_add -> f_add_
    # Signature: All arguments are pointers!
    affix $lib, 'f_add_', [ Pointer [Int], Pointer [Int], Pointer [Int] ] => Void;

    # Strings: A pointer to characters, PLUS a hidden length argument (size_t)
    # at the very end of the argument list.
    affix $lib, 'f_hello_', [ String, Size_t ] => Void;

    # 3. Call (Math)
    # We must pass references to our numbers
    my $a   = 10;
    my $b   = 20;
    my $res = 0;
    f_add_( \$a, \$b, \$res );
    say "10 + 20 = $res";    # 30

    # 4. Call (Strings)
    my $msg = "Hello World";

    # We pass the string, AND its length manually as the hidden argument.
    f_hello_( $msg, length($msg) );

=head2 How It Works

=over 4

=item B<1. Pass By Reference>

Fortran does not have "value" arguments. Even a simple integer input must be passed as a pointer. In Affix, we use
C<Pointer[Int]> and pass a scalar reference (C<\$a>).

=item B<2. Hidden Lengths>

When passing `character` arrays (strings), gfortran expects the pointer to the data I<first>, and the length of the
string I<at the very end> of the argument list (passed by value).

    Fortran: subroutine f(str1, int, str2)
    C ABI:   void f_(char *str1, int *int, char *str2, size_t len1, size_t len2)

=back

=head2 Kitchen Reminders

=over 4

=item * B<Dependencies>

Shared libraries compiled with C<gfortran> usually depend on C<libgfortran.so>. If you load your library and get
"Symbol not found" errors, you may need to preload C<libgfortran> using C<load_library>.

=back

=head1 Chapter 35: Coroutines (Green Threads)

Coroutines allow functions to pause execution, yield control, and resume later. This is the basis of "Green Threads" or
"Fibers" found in languages like Go or Ruby.

We can implement this in C using Fibers on Windows and C<ucontext.h> on POSIX systems. Let's create a C task scheduler
driven by Perl.

=head2 The Recipe

B<Note: This recipe works on Linux/BSD only (POSIX).>

We will create a cross-platform C task scheduler. Perl will trigger the context switches.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    $|++;

    # 1. Compile Cross-Platform Context Manager
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
    #include <stdlib.h>
    #include <stdio.h>

    // Windows Fibers
    #ifdef _WIN32
        #include <windows.h>

        static void *ctx_main;
        static void *ctx_task;

        // Fiber Entry Point
        void __stdcall task_entry(void *arg) {
            printf("[C] Task Started. Yielding...\n");
            SwitchToFiber(ctx_main);
            printf("[C] Task Resumed. Finishing...\n");

            // On Windows, a fiber usually switches back before exiting
            // or the thread exits. We switch back to main to be safe.
            SwitchToFiber(ctx_main);
        }

        void init_task() {
            // 1. Convert current thread to a Fiber (required)
            if (!ctx_main)
                ctx_main = ConvertThreadToFiber(NULL);

            // 2. Create the new Fiber
            ctx_task = CreateFiber(0, task_entry, NULL);
        }

        void run_scheduler() {
            printf("[C] Scheduler: Switching to Task\n");
            fflush(stdout);
            SwitchToFiber(ctx_task);
            printf("[C] Scheduler: Back in Main\n");
            fflush(stdout);
        }
    // POSIX ucontext
    #else
        #include <ucontext.h>

        static ucontext_t ctx_main, ctx_task;
        static char stack[16384];

        void task_entry() {
            printf("[C] Task Started. Yielding...\n");
            swapcontext(&ctx_task, &ctx_main);
            printf("[C] Task Resumed. Finishing...\n");
        }

        void init_task() {
            getcontext(&ctx_task);
            ctx_task.uc_stack.ss_sp = stack;
            ctx_task.uc_stack.ss_size = sizeof(stack);
            ctx_task.uc_link = &ctx_main;
            makecontext(&ctx_task, task_entry, 0);
        }

        void run_scheduler() {
            printf("[C] Scheduler: Switching to Task\n");
            swapcontext(&ctx_main, &ctx_task);
            printf("[C] Scheduler: Back in Main\n");
        }
    #endif
    END
    my $lib = $c->link;

    # 2. Bind
    affix $lib, 'init_task',     [] => Void;
    affix $lib, 'run_scheduler', [] => Void;

    # 3. Execute
    init_task();
    say '[Perl] Step 1: Run Task (Start)';
    run_scheduler();
    say '[Perl] Step 2: Run Task (Resume)';
    run_scheduler();
    say '[Perl] Done.';

=head2 How It Works

=over

=item 1a. B<Windows Fibers>

Windows requires a thread to be "converted" to a Fiber before it can schedule other fibers.[1][2][5]
C<ConvertThreadToFiber> returns a handle representing the current execution context. C<CreateFiber> allocates a new
stack and returns a handle to it. C<SwitchToFiber> saves the current CPU state and jumps to the target handle.

=item 1b. B<POSIX ucontext>

POSIX C<makecontext> prepares a new stack buffer. C<swapcontext> saves the current registers and restores the target's
registers.

=item 2. B<Cooperative Multitasking>

In both cases, the "Task" function explicitly yields control back to "Main". This pauses the function in the middle of
execution. When "Main" calls the scheduler again, execution resumes exactly where it left off (after the yield).

=back

=head2 Output

    [Perl] Step 1: Run Task (Start)
    [C] Scheduler: Switching to Task
    [C] Task Started. Yielding...
    [C] Scheduler: Back in Main
    [Perl] Step 2: Run Task (Resume)
    [C] Scheduler: Switching to Task
    [C] Task Resumed. Finishing...
    [C] Scheduler: Back in Main
    [Perl] Done.

Notice how `task_body` ran in two pieces, interrupted by Perl logic in the middle.

=head2 Kitchen Reminders

=over 4

=item B<Don't Cross the Streams>

You generally cannot call Perl code from inside a swapped context. The Perl interpreter assumes it is running on the
main stack. If you try to run a Perl callback from inside `task_body`, the interpreter might get confused about its
stack depth and crash. Use this for C-only number crunching tasks.

=back

=head1 Chapter 36: Coroutines (The Ping-Pong Pattern)

Running the Perl interpreter on a C-allocated stack is dangerous. Security features (like glibc's stack smashing
protection) and internal caching (Windows TLS) will kill the process.

To get the magic of Green Threads without the Segfaults, we use the Ping-Pong Pattern.

=over

=item C does work, then Yields a request to Perl.

=item Perl (on the main stack) receives the request, executes the code, and Resumes C.

=item C wakes up, thinking it just called a function, and continues.

=back

=head2 The Recipe

We will build a C task that counts up. At each step, it asks Perl to print the number and verify if it should continue.

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    $|++;

    # 1. Compile Context Manager
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
    #include <stdlib.h>
    #include <stdio.h>
    #include <stdint.h>
    #include <string.h>

    // Platform abstraction
    #ifdef _WIN32
        #include <windows.h>
        typedef LPVOID ctx_t;
        static ctx_t g_main, g_task;
        #define INIT() if(!g_main) g_main = ConvertThreadToFiber(NULL)
        #define MAKE_CTX(fn, arg) CreateFiber(0, fn, arg)
        #define SWAP(to) SwitchToFiber(to)
        #define ENTRY_POINT(n) void __stdcall n(void *arg)
    #else
        #include <ucontext.h>
        typedef ucontext_t ctx_t;
        static ctx_t g_main, g_task;
        static char stack[64 * 1024]; // 64KB Stack
        #define INIT()
        #define SWAP(to) swapcontext(&g_task, &g_main)
        #define ENTRY_POINT(n) void n()
    #endif

    // Global exchange buffer
    static int g_val = 0;
    static int g_keep_going = 1;

    // The Task Logic (Stateful C)
    ENTRY_POINT(task_body) {
        printf("[C] Task: Entering loop...\n");
        fflush(stdout);
        for (int i = 1; i <= 5; i++) {
            g_val = i;

            // YIELD TO MAIN
            // We pause here. Main runs. We resume here.
            #ifdef _WIN32
                SwitchToFiber(g_main);
            #else
                swapcontext(&g_task, &g_main);
            #endif

            // We are back! Check value from Perl
            if (!g_keep_going) {
                printf("[C] Task: Perl told me to stop at %d.\n", i);
                break;
            }
        }

        printf("[C] Task: Finished.\n");
        g_val = -1; // Sentinel for done

        // Final return to main
        #ifdef _WIN32
            SwitchToFiber(g_main);
        #else
            swapcontext(&g_task, &g_main);
        #endif
    }

    void init_task() {
        INIT();
        #ifdef _WIN32
            g_task = MAKE_CTX(task_body, NULL);
        #else
            getcontext(&g_task);
            g_task.uc_stack.ss_sp = stack;
            g_task.uc_stack.ss_size = sizeof(stack);
            g_task.uc_link = &g_main;
            makecontext(&g_task, task_body, 0);
        #endif
    }

    // Resume the task. Returns the value yielded by the task.
    int resume_task(int keep_going) {
        g_keep_going = keep_going;

        #ifdef _WIN32
            SwitchToFiber(g_task);
        #else
            swapcontext(&g_main, &g_task);
        #endif

        return g_val;
    }
    END
    my $lib = $c->link;

    # 2. Bind
    affix $lib, 'init_task',   []    => Void;
    affix $lib, 'resume_task', [Int] => Int;

    # 3. Usage
    say "[Perl] Initializing...";
    init_task();
    while (1) {
        say "[Perl] Resuming C task...";

        # Pass data IN (1), Get data OUT ($val)
        my $val = resume_task(1);
        if ( $val == -1 ) {
            say "[Perl] Task finished.";
            last;
        }
        say "[Perl] C yielded value: $val";
        if ( $val == 3 ) {
            say "[Perl] Asking C to stop early...";
            resume_task(0);    # Pass 0 to tell C to stop
            last;
        }
    }

=head2 How It Works

=over 4

=item B<1. The Stack Swap>

When Perl calls C<resume_task>, the C code saves the "Main" state (stack pointer, registers) and jumps to the "Task"
state. The Perl script effectively pauses inside the C<resume_task> C call.

=item B<2. The Yield>

The C function C<task_body> runs until it decides it needs input/output. It sets a global variable (C<g_val>) and swaps
context back to "Main".

To Perl, C<resume_task> finally returns. Perl is now running on the B<Main Stack> again, so it can safely do anything
(regexes, I/O, objects).

=item B<3. The Loop>

Perl processes the data, then calls C<resume_task> again. The C function wakes up exactly where it left off (after the
swap), reads the new input (C<g_keep_going>), and continues its loop.

=back

=head2 Why this is better?

Attempting to run the Perl Interpreter itself on a Fiber/Secondary Stack usually results in crashes due to:

=over

=item Linux: C<_FORTIFY_SOURCE> detecting stack pointer jumps.

=item Windows: Thread Local Storage (TLS) indices desynchronizing.

=back

By keeping Perl on the Main Stack and only running C logic on the Fiber, we get 100% stability and full Coroutine
behavior.

### Chapter 37: The Coroutine Scheduler (Multiple Fibers)

In Chapter 36, we built a single task. But the real power of Green Threads comes from concurrency: running multiple
tasks that yield to each other.

We will build a **Round-Robin Scheduler** in Perl. We will create multiple C "Fibers", each with its own stack and
local state. Perl will loop through them, resuming each one until they all complete.

=head2 The Recipe

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;

    # 1. Compile the Fiber Engine
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdint.h>

    // Context API
    #ifdef _WIN32
        #include <windows.h>
        typedef LPVOID ctx_t;

        // Robust Fiber Initialization
        static int g_is_converted = 0;
        static void ensure_fiber() {
            if (!g_is_converted) {
                ConvertThreadToFiber(NULL);
                g_is_converted = 1;
            }
        }

        #define INIT_MAIN() ensure_fiber()
        #define MAKE_CTX(fn, arg) CreateFiber(0, fn, arg)
        #define SWAP(from, to) SwitchToFiber(to)
        #define ENTRY_POINT(n) void __stdcall n(void *arg)
    #else
        #include <ucontext.h>
        typedef ucontext_t* ctx_t;
        // 64KB Stack per fiber
        #define STACK_SIZE (64 * 1024)
        #define INIT_MAIN()
        // Swap: Save 'from', Jump 'to'
        #define SWAP(from, to) swapcontext(from, to)
        #define ENTRY_POINT(n) void n(void *arg)

        // POSIX requires a trampoline to handle pointer arguments safely
        static void posix_entry(int hi, int lo);
    #endif

    // Fiber Structure
    typedef struct Fiber {
        ctx_t ctx;          // The context (registers + stack)
        ctx_t caller;       // The scheduler's context
        char *stack;        // Stack memory (POSIX only)

        // Local State for our Demo
        char name[16];
        int count_target;
        int current;
        int is_done;
    } Fiber;

    // Track the currently running fiber so it knows where to yield
    static Fiber *g_current = NULL;

    // Core Logic

    // Yield control back to the scheduler
    void fiber_yield() {
        if (g_current) {
            #ifdef _WIN32
            SWAP(NULL, g_current->caller);
            #else
            SWAP(g_current->ctx, g_current->caller);
            #endif
        }
    }

    // The "Task" - A C function with local state
    void run_task_logic(Fiber *f) {
        printf("[C] %s: Starting. Target=%d\n", f->name, f->count_target);

        for (int i = 1; i <= f->count_target; i++) {
            f->current = i;

            // Pause execution and return to Perl
            fiber_yield();

            // Resumed! The C stack is exactly as we left it.
            printf("[C] %s: Resumed inside loop (i=%d)\n", f->name, i);
        }

        printf("[C] %s: Finished.\n", f->name);
        f->is_done = 1;

        // Final return to scheduler
        fiber_yield();
    }

    // Entry Points
    #ifdef _WIN32
        ENTRY_POINT(fiber_entry) {
            run_task_logic((Fiber*)arg);
        }
    #else
        void posix_entry(int hi, int lo) {
            // Reassemble pointer (split to avoid 32-bit int overflow on arguments)
            uintptr_t ptr = ((uintptr_t)hi << 32) | (uint32_t)lo;
            run_task_logic((Fiber*)ptr);
        }
    #endif

    // Exported API

    Fiber* create_fiber(const char* name, int count) {
        INIT_MAIN();
        Fiber *f = calloc(1, sizeof(Fiber));
        strncpy(f->name, name, 15);
        f->count_target = count;

        #ifdef _WIN32
            f->ctx = MAKE_CTX(fiber_entry, f);
        #else
            f->ctx = malloc(sizeof(ucontext_t));
            f->stack = malloc(STACK_SIZE);
            getcontext(f->ctx);
            f->ctx->uc_stack.ss_sp = f->stack;
            f->ctx->uc_stack.ss_size = STACK_SIZE;
            f->ctx->uc_link = NULL;

            uintptr_t ptr = (uintptr_t)f;
            // Split 64-bit pointer into two 32-bit ints
            makecontext(f->ctx, (void(*)())posix_entry, 2,
                (int)(ptr >> 32), (int)(ptr & 0xFFFFFFFF));
        #endif
        return f;
    }

    int resume_fiber(Fiber *f) {
        if (f->is_done) return -1;

        Fiber *prev = g_current;
        g_current = f;

        #ifdef _WIN32
            f->caller = GetCurrentFiber();
            SWAP(NULL, f->ctx);
        #else
            // Save Main context into f->caller, Switch to f->ctx
            if (!f->caller) f->caller = malloc(sizeof(ucontext_t));
            SWAP(f->caller, f->ctx);
        #endif

        g_current = prev;
        return f->current;
    }

    int is_done(Fiber *f) { return f->is_done; }

    void destroy_fiber(Fiber *f) {
        #ifdef _WIN32
            DeleteFiber(f->ctx);
        #else
            free(f->stack);
            free(f->ctx);
            if (f->caller) free(f->caller);
        #endif
        free(f);
    }
    END
    my $lib = $c->link;

    # 2. Define Opaque Handle
    typedef FiberPtr => Pointer [Void];
    affix $lib, 'create_fiber',  [ String, Int ] => FiberPtr();
    affix $lib, 'resume_fiber',  [ FiberPtr() ]  => Int;
    affix $lib, 'is_done',       [ FiberPtr() ]  => Int;
    affix $lib, 'destroy_fiber', [ FiberPtr() ]  => Void;

    # 3. Create Fibers (The "Thread" Objects)
    my @fibers;
    push @fibers, create_fiber( "Worker A", 3 );
    push @fibers, create_fiber( "Worker B", 5 );

    # 4. The Scheduler Loop
    say "[Perl] Starting Scheduler...";
    while (@fibers) {
        my $f = shift @fibers;    # Round-robin: take from front

        # Resume C execution
        my $count = resume_fiber($f);
        if ( is_done($f) ) {
            say "[Perl] Task Complete. Cleaning up.";
            destroy_fiber($f);
        }
        else {
            say "[Perl] Task yielded value: $count";
            push @fibers, $f;    # Put back in queue
        }
    }
    say "[Perl] All tasks finished.";

=head2 The Output

    [Perl] Starting Scheduler...
    [C] Worker A: Starting. Target=3
    [Perl] Task yielded value: 1
    [C] Worker B: Starting. Target=5
    [Perl] Task yielded value: 1
    [C] Worker A: Resumed inside loop (i=1)
    [Perl] Task yielded value: 2
    [C] Worker B: Resumed inside loop (i=1)
    [Perl] Task yielded value: 2
    [C] Worker A: Resumed inside loop (i=2)
    [Perl] Task yielded value: 3
    [C] Worker B: Resumed inside loop (i=2)
    [Perl] Task yielded value: 3
    [C] Worker A: Resumed inside loop (i=3)
    [C] Worker A: Finished.
    [Perl] Task Complete. Cleaning up.
    [C] Worker B: Resumed inside loop (i=3)
    [Perl] Task yielded value: 4
    [C] Worker B: Resumed inside loop (i=4)
    [Perl] Task yielded value: 5
    [C] Worker B: Resumed inside loop (i=5)
    [C] Worker B: Finished.
    [Perl] Task Complete. Cleaning up.
    [Perl] All tasks finished.

=head2 Why This Matters

This demonstrates that you can use Affix to implement complex control flow structures. The C functions C<create_fiber>
and C<resume_fiber> effectively give you a library-specific threading engine that communicates with Perl values.

You could use this to wrap:

=over

=item * Game loops (C logic yields every frame).

=item * Parsers (C logic yields every token).

=item * Simulation steps (C logic yields every tick).

=back

And you can drive it all from a simple Perl C<while> loop.





You have hit on the "Holy Grail" of FFI: True Green Threads for Perl.

However, as we saw in the crash logs from Chapter 36, **pausing the Perl Interpreter mid-execution by swapping the C
stack underneath it is dangerous**. Perl caches stack pointers and thread-local data that become invalid when you swap
stacks, leading to `SIGSEGV` or `SIGABRT`.

But we can achieve **Safe Concurrency** using the **Actor Model**.

Instead of pausing Perl *inside* a subroutine, we design Perl objects ("Actors") that perform one "tick" of work and
then return. The C Fiber maintains the loop, the context, and the scheduling.

This allows us to run thousands of stateful Perl objects concurrently, driven by a high-performance C scheduler.

=head3 Chapter 38: The Actor Model (Safe Concurrency)

We will build a system where B<C> manages the control flow (looping, waiting, yielding) and B<Perl> manages the logic.

Each "Actor" has:

=over

=item 1. A B<Perl Object> (holding state like names, counters, buffers).

=item 2. A B<C Fiber> (holding the execution loop).

=back

The C Fiber calls the Perl object's C<tick()> method. If the method returns "Keep Going", the Fiber yields to the next
actor. If it returns "Done", the Fiber exits.

This allows us to simulate multitasking (like a game engine or simulation) without crashing the interpreter.

=head2 The Recipe

    use v5.40;
    use feature 'class';
    no warnings 'experimental::class';
    use Affix qw[:all];
    use Affix::Compiler;
    $|++;

    # 1. Compile the Actor Engine
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
        #include <stdlib.h>
        #include <stdio.h>
        #include <stdint.h>

        // Context Abstraction (Same as Ch 37)
        #ifdef _WIN32
            #include <windows.h>
            typedef LPVOID ctx_t;
            static int g_init = 0;
            #define INIT_MAIN() if(!g_init) { ConvertThreadToFiber(NULL); g_init=1; }
            #define MAKE_CTX(fn, arg) CreateFiber(0, fn, arg)
            #define SWAP(from, to) SwitchToFiber(to)
            #define ENTRY_POINT(n) void __stdcall n(void *arg)
        #else
            #include <ucontext.h>
            typedef ucontext_t* ctx_t;
            #define STACK_SIZE (32 * 1024)
            #define INIT_MAIN()
            #define SWAP(from, to) swapcontext(from, to)
            #define ENTRY_POINT(n) void n(void *arg)
            static void posix_entry(int hi, int lo);
        #endif

        // Actor System

        // Callback: int tick(SV* obj)
        // Returns: 1 = Yield/Continue, 0 = Done
        typedef int (*tick_cb_t)(void*);

        typedef struct Actor {
            ctx_t ctx;
            ctx_t scheduler;
            #ifndef _WIN32
            char *stack;
            #endif

            void *perl_obj; // SV* (The Perl Object)
            tick_cb_t tick; // The Perl Callback
            int is_alive;
        } Actor;

        static Actor *g_current = NULL;

        // The "Game Loop" running inside the Fiber
        void actor_loop(Actor *a) {
            // Keep calling Perl until it says "stop"
            while (1) {
                // 1. Call Perl
                int keep_going = a->tick(a->perl_obj);

                // 2. Check result
                if (!keep_going) break;

                // 3. Yield to Scheduler
                // We save our state here and pause.
                #ifdef _WIN32
                    SWAP(NULL, a->scheduler);
                #else
                    SWAP(a->ctx, a->scheduler);
                #endif
            }

            a->is_alive = 0;
            // Final return
            #ifdef _WIN32
                SWAP(NULL, a->scheduler);
            #else
                SWAP(a->ctx, a->scheduler);
            #endif
        }

        #ifdef _WIN32
            ENTRY_POINT(fiber_entry) { actor_loop((Actor*)arg); }
        #else
            void posix_entry(int hi, int lo) {
                uintptr_t ptr = ((uintptr_t)hi << 32) | (uint32_t)lo;
                actor_loop((Actor*)ptr);
            }
        #endif

        // API

        Actor* spawn_actor(void *perl_obj, tick_cb_t cb) {
            INIT_MAIN();
            Actor *a = calloc(1, sizeof(Actor));
            a->perl_obj = perl_obj;
            a->tick = cb;
            a->is_alive = 1;

            #ifdef _WIN32
                a->ctx = MAKE_CTX(fiber_entry, a);
            #else
                a->ctx = malloc(sizeof(ucontext_t));
                a->stack = malloc(STACK_SIZE);
                getcontext(a->ctx);
                a->ctx->uc_stack.ss_sp = a->stack;
                a->ctx->uc_stack.ss_size = STACK_SIZE;
                a->ctx->uc_link = NULL;
                uintptr_t ptr = (uintptr_t)a;
                makecontext(a->ctx, (void(*)())posix_entry, 2,
                    (int)(ptr >> 32), (int)(ptr & 0xFFFFFFFF));
            #endif
            return a;
        }

        void run_slice(Actor *a) {
            if (!a->is_alive) return;

            Actor *prev = g_current;
            g_current = a;

            #ifdef _WIN32
                a->scheduler = GetCurrentFiber();
                SWAP(NULL, a->ctx);
            #else
                if (!a->scheduler) a->scheduler = malloc(sizeof(ucontext_t));
                SWAP(a->scheduler, a->ctx);
            #endif

            g_current = prev;
        }

        int is_alive(Actor *a) { return a->is_alive; }

        // Don't forget cleanup in real code!
    END
    my $lib = $c->link;

    # 2. Define Types
    typedef ActorPtr => Pointer [Void];
    typedef TickCB   => Callback [ [ Pointer [SV] ] => Int ];    # Pass SV* directly
    affix $lib, 'spawn_actor', [ Pointer [SV], TickCB() ] => ActorPtr();
    affix $lib, 'run_slice',   [ ActorPtr() ]             => Void;
    affix $lib, 'is_alive',    [ ActorPtr() ]             => Int;

    # 3. The Perl Class
    class NPC {
        field $name : param;
        field $hp : param //= 10;

        method tick {
            say "  [$name] HP: $hp";
            $hp -= int( rand(4) );
            if ( $hp <= 0 ) {
                say "  [$name] Died!";
                return 0;    # Stop
            }
            return 1;        # Keep Going
        }
    }

    # 4. The Scheduler
    my @actors;

    # We must keep the callback alive!
    my $tick_handler = sub ($obj) {

        # Affix passes the SV*. We must dereference it to get the object.
        # But wait! 'spawn_actor' received the object directly.
        # Affix's SV type mapping handles this.
        return $obj->tick();
    };

    # Spawn 3 Actors
    my @orcs = push @actors, spawn_actor( $_, $tick_handler ) for map { NPC->new( name => $_ ) } qw[Orc Elf Wizard Human];
    say 'Simulation Start';
    my $round = 1;
    while (@actors) {
        say "Round $round:";

        # Run each actor for one "slice"
        run_slice($_) for @actors;

        # Remove dead actors
        @actors = grep { is_alive($_) } @actors;
        $round++;
        sleep 1;
    }
    say 'Game Over';

=head2 How It Works

=over 4

=item B<1. The SV Type>

    affix ..., [ Pointer[SV], TickCB() ] ...

We use the B<SV*> to pass the Perl Object (reference) directly to C. C stores it as a `void*`. When C calls the
callback, it passes that `void*` back. Affix's `Callback` logic receives the `void*`, sees the signature expects an
`SV`, and hands the Perl Object back to the subroutine.

This creates a seamless loop: Perl Object -> C Storage -> Perl Method.

=item B<2. Safe Concurrency>

Although we are switching C stacks, the Perl code always runs on the main stack.

=over

=item 1. C Fiber runs `actor_loop`.

=item 2. C calls `a->tick()`.

=item 3. **Affix Trampoline** executes on the C Fiber stack? **NO.**

Affix detects the stack boundary and ensures the Perl callback runs safely. (Actually, in this specific "Ping-Pong"
model, we rely on the Perl interpreter's re-entrancy. Since we return to Perl before `yield`, the stack unwinds
safely).

=back

Wait, so the diagram is:

    Main -> run_slice (C) -> [Swap] -> Fiber (C) -> tick (Perl)

Yep. Here, `tick` **is** running on top of the Fiber stack.

Unlike Chapter 36 (where we yielded *before* running Perl), here we run Perl *inside* the Fiber.

Why does this work here?

Because `tick` is a leaf function. It runs, does simple logic, and **Returns**. It does not try to `yield` or `suspend`
the Perl interpreter itself. It just modifies the object and returns an int. As long as the Perl sub returns normally,
the C stack frame remains valid.

The crash happens if you try to `switch_stack` *while inside* the Perl sub. Here, we return to C, and *C* switches the
stack.

=back

=head2 Kitchen Reminders

=over 4

=item * The Golden Rule of Fibers: B<Never yield from within Perl.>

Always return to C, let C yield, and have C call you back later. This keeps the Perl interpreter happy and stable.

=back

=head3 Chapter 39: Linear Coroutines (Flattening the Pyramid)

The nested callbacks in the previous chapter are hard to read. We can improve the user experience significantly by
abstracting the "State Machine" logic into the C layer.

Instead of a single callback, we will pass an **Array of Callbacks** to C. The C scheduler maintains an index. Every
time the task runs, C calls the next function in the list.

=head2 The Recipe

    use v5.40;
    use Affix qw[:all];
    use Affix::Compiler;
    use Time::HiRes qw[time];

    # 1. Compile C Scheduler
    my $c = Affix::Compiler->new();
    $c->add( \<<~'END', lang => 'c' );
    #include <stdlib.h>
    #include <stdio.h>

    // Standard Perl API helpers usually provided by XS,
    // but we are in pure C mode here.
    typedef void* SV;
    typedef void* AV;

    typedef struct Task {
        int id;
        SV  **steps;      // Array of CodeRefs
        int step_count;   // Total steps
        int current_step; // Instruction Pointer
        double wake_time; // Sleep timer

        // Context storage (User Data)
        // We hold a Perl HashRef here to share state between steps
        SV context;

        struct Task *next;
    } Task;

    // Callbacks provided by Perl to handle AV* manipulation
    typedef SV (*get_step_cb)(SV *steps, int index);

    static Task *head = NULL;
    static Task *tail = NULL;
    static int next_id = 1;
    static get_step_cb g_fetcher = NULL;

    void register_fetcher(get_step_cb cb) {
        g_fetcher = cb;
    }

    void spawn(SV **steps, int count, SV context) {
        Task *t = calloc(1, sizeof(Task));
        t->id = next_id++;
        t->steps = steps;
        t->step_count = count;
        t->current_step = 0;
        t->context = context;

        if (tail) tail->next = t;
        else      head = t;
        tail = t;
    }

    // Returns:
    //  0 = Idle/Done
    //  1 = Ran a step
    int run_tick(double now) {
        if (!head) return 0;

        // Round-robin
        Task *t = head;
        head = t->next;
        if (!head) tail = NULL;

        // 1. Check Sleep
        if (t->wake_time > now) {
            // Re-queue
            t->next = NULL;
            if (tail) tail->next = t;
            else      head = t;
            tail = t;
            return 0; // Waiting
        }

        // 2. Check Done
        if (t->current_step >= t->step_count) {
            printf("[C] Task %d finished.\n", t->id);
            free(t);
            return 1; // Did work (cleaned up)
        }

        // 3. Get Current Step (CodeRef)
        // We call back to Perl to fetch from the AV
        SV code_ref = g_fetcher(t->steps, t->current_step);

        // 4. Return to Perl to Execute
        // We give Perl the CodeRef, the Context, and the Task pointer.
        // Perl executes the code, and calls 'task_sleep' if needed.
        // We increment step *before* returning, assuming success.
        t->current_step++;

        // We return the Task* so Perl can read the CodeRef from it
        // (or we could return a struct, but let's keep C simple).

        // Re-queue
        t->next = NULL;
        if (tail) tail->next = t;
        else      head = t;
        tail = t;

        return 1; // Signal that we are ready to run 'code_ref'
    }

    // Helpers
    SV task_get_code(Task *t) {
        // We actually need to re-fetch because we can't return SV easily
        // from run_tick without a struct return.
        // Let's rely on Perl holding the list.
        return g_fetcher(t->steps, t->current_step - 1);
    }

    SV task_get_context(Task *t) { return t->context; }

    void task_sleep(Task *t, double duration) {
        // Perl calls this to pause the task
        // We set the wake time relative to now (passed from Perl?)
        // Actually, let's pass absolute time from Perl for precision.
        t->wake_time = duration;
    }

    // Peek at head to see if we should run
    Task* peek_next() { return head; }

    END
    my $lib = $c->link;

    # 2. Bindings
    typedef TaskPtr => Pointer [Void];

    # Helper to fetch from AV (ArrayRef)
    my $fetcher = sub ( $av_ref, $idx ) {
        return $av_ref->[$idx];
    };
    affix $lib, 'register_fetcher', [ Callback [ [ Pointer [SV], Int ] => Pointer [SV] ] ] => Void;
    affix $lib, 'spawn',            [ Pointer [SV], Int, Pointer [SV] ]                    => Void;
    affix $lib, 'peek_next',        []                                                     => TaskPtr();
    affix $lib, 'run_tick',         [Double]                                               => Int;
    affix $lib, 'task_get_code',    [ TaskPtr() ]                                          => Pointer [SV];
    affix $lib, 'task_get_context', [ TaskPtr() ]                                          => Pointer [SV];
    affix $lib, 'task_sleep',       [ TaskPtr(), Double ]                                  => Void;

    # Init
    register_fetcher($fetcher);

    # 3. User API (The Sugar)
    # This makes the syntax clean.
    sub task ( $name, @steps ) {

        # Create a shared context hash for this task
        my $ctx = { name => $name };

        # Pass the ArrayRef directly to C
        # Note: We must keep @steps alive in Perl memory!
        # Ideally, store it in a global registry.
        state @registry;
        my $steps_ref = \@steps;
        push @registry, $steps_ref;
        spawn( $steps_ref, scalar(@steps), $ctx );
    }

    # 4. Define Tasks (Linear Style!)
    task "Worker A", sub ($ctx) {
        say "[$ctx->{name}] Step 1: Init";
        $ctx->{count} = 0;
    }, sub ($ctx) {
        say "[$ctx->{name}] Step 2: Working...";
        $ctx->{count}++;
    }, sub ($ctx) {
        say "[$ctx->{name}] Step 3: Done (Count $ctx->{count})";
    };
    task "Worker B", sub ($ctx) {
        say "[$ctx->{name}] Step 1: Start";
    }, sub ($ctx) {
        say "[$ctx->{name}] Step 2: Sleeping 1s...";

        # We need to signal the C task to sleep
        # But we are inside Perl... how do we get the TaskPtr?
        # See "The Scheduler" below.
        return 1.0;    # Return value = Sleep duration
    }, sub ($ctx) {
        say "[$ctx->{name}] Step 3: Woke up!";
    };

    # 5. The Scheduler Loop
    say "[System] Loop Starting...";
    while (1) {
        my $now = time();

        # 1. Check if C has a task ready
        my $t = peek_next();
        if ( is_null($t) ) {

            # Queue empty or everyone sleeping
            # In a real app, we would sleep/select here
            last;
        }

        # 2. Advance C state
        # This moves the pointer, checks timers, etc.
        # If it returns 0, the task was sleeping or queue empty.
        if ( run_tick($now) == 1 ) {

            # 3. Execute Perl
            my $code = task_get_code($t);
            my $ctx  = task_get_context($t);

            # Run the step!
            my $sleep_req = $code->($ctx);

            # Handle sleep request
            if ($sleep_req) {
                task_sleep( $t, $now + $sleep_req );
            }
        }
    }
    say "[System] Loop Finished.";

=head2 How It Works

=over 4

=item B<1. The Structure>

Instead of one function that pauses, we define a B<List of Functions>. This effectively creates a State Machine where
the "Instruction Pointer" (`current_step`) is managed by C.

=item B<2. Shared Context>

    sub ($ctx) { ... }

We pass a HashRef (`$ctx`) to `spawn`. Affix stores this `SV*` in the C struct. Every time the C scheduler picks this
task, it retrieves that specific `SV*` and passes it back to the current Perl subroutine. This allows variables to
persist between steps (like `$ctx->{count}`).

=item B<3. The Hybrid Loop>

    run_tick($now); // C Logic
    $code->($ctx);  // Perl Logic

C handles the "Hard" stuff: Queue management, Time comparisons, and Memory layout. Perl handles the "Soft" stuff:
Business logic and I/O.

=back

=head2 Why use this?

This pattern allows you to write incredibly complex, stateful asynchronous workflows (like a login handshake, a game AI
behavior tree, or a retry policy) as a simple list of steps, completely avoiding the "Callback Hell" of nested
closures.

=cut
