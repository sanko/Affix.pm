=pod

=encoding utf-8

=head1 NAME

Affix::Bind - Frictionless C Header Introspection and FFI Wrapper Generation

=head1 SYNOPSIS

    use Affix::Bind;

    # Configure the binder
    my $binder = Affix::Bind->new(
        project_files => [ 'include/mylib.h' ],
        include_dirs  => [ 'include/' ],
    );

    # Parse headers into an AST
    my $ast = $binder->parse;

    for my $node (@$ast) {

        # Functions
        if ( $node isa Affix::Bind::Function ) {
            # Generate: affix $lib, 'func_name' => [Args], Ret;
            say $node->affix_type;
        }

        # Typedefs (often wrapping Structs/Enums)
        elsif ( $node isa Affix::Bind::Typedef ) {
            say "typedef " . $node->name . " => " . $node->underlying->affix_type;

            # Inspect underlying Struct
            if ( $node->underlying isa Affix::Bind::Struct ) {
                my $struct = $node->underlying;
                say "  Members:";
                for my $m (@{$struct->members}) {
                    say "    " . $m->name . " (" . $m->affix_type . ")";
                }
            }
        }

        # Global Variables
        elsif ( $node isa Affix::Bind::Variable ) {
            say $node->affix_type; # Generates 'pin my $var ...'
        }
    }

=head1 DESCRIPTION

C<Affix::Bind> acts as a bridge between C/C++ header files and the B<Affix> FFI system. It parses headers to produce a
structured object model representing functions, structs, enums, typedefs, and variables.

It is designed to normalize the output between its two internal drivers (Clang and Regex) so that downstream code
generation remains consistent regardless of the environment.

=head1 CONSTRUCTOR

=head2 C<new( ... )>

    my $binder = Affix::Bind->new(
        project_files => [ 'lib.h' ],
        include_dirs  => [ '/usr/include' ],
    );

=over

=item C<project_files>

Required. Array reference of C header files to parse.

=item C<include_dirs>

Optional. Array reference of include paths.

=back

=head1 DATA MODEL

The C<parse()> method returns a list of objects.

=head2 Affix::Bind::Type

Represents a generic C type (e.g., C<int>, C<void>).

=over

=item * C<affix_type>: Returns the Affix signature string (e.g., C<Int>).

=item * C<affix>: Returns the actual Affix type object.

=back

=head2 Affix::Bind::Type::Pointer

Represents C<T*> types. Wraps another type object.

=head2 Affix::Bind::Type::Array

Represents C<T[N]> fixed-size arrays. Wraps a type object and a count.

=head2 Affix::Bind::Type::CodeRef

Represents function pointers (callbacks), e.g., C<void (*)(int)>.

=over

=item * C<ret>: Return type object.

=item * C<params>: ArrayRef of argument type objects.

=item * C<affix_type>: Returns C<Callback[[Args] => Ret]>.

=back

=head2 Affix::Bind::Argument

Function arguments.

=head2 Affix::Bind::Member

Struct/Union members.

=over

=item * C<definition>: If the member defines a nested struct/union inline, this holds that definition object.

=item * C<affix_type>: Returns the signature of the type OR the nested definition.

=back

=head2 Affix::Bind::Function

A C function declaration.

=over

=item * C<affix_type>: Returns a complete Perl string to bind this function (e.g., C<affix $lib, name => ...>).

=back

=head2 Affix::Bind::Struct

A C struct or union definition.

=over

=item * C<tag>: Either 'struct' or 'union'.
=item * C<affix_type>: Returns C<Struct[ ... ]> or C<Union[ ... ]>.

=back

=head2 Affix::Bind::Typedef

A name alias for another type.

=over

=item * C<underlying>: The type object being aliased.

=back

B<Note:> In C, C<typedef struct { ... } Name;> results in a C<Typedef> object where C<underlying> is the C<Struct>
object.

=head2 Affix::Bind::Enum

An enumeration.

=over

=item * C<affix_type>: Returns C<Enum[ Name => Val, ... ]>. String values in enums are quoted automatically.

=back

=head2 Affix::Bind::Variable

A global C<extern> variable.

=over

=item * C<affix_type>: Returns a C<pin my $var ...> string.

=back

=head2 Affix::Bind::Macro

A preprocessor C<#define>.

=over

=item * C<affix_type>: Returns a C<use constant> string. Expressions (e.g., C<A + B>) are quoted as strings to prevent compile-time errors in Perl, while literals are preserved.

=back

=cut
