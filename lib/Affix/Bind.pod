=pod

=encoding utf-8

=head1 NAME

Affix::Bind - Frictionless C Header Introspection

=head1 SYNOPSIS

    use v5.40;
    use Affix::Bind;
    use Affix;

    # Configure
    my $binder = Affix::Bind->new(
        project_files => [ 'include/mylib.h' ],
        include_dirs  => [ '/usr/local/include' ]
    );

    # Parse
    my $ast = $binder->parse;

    # Use (Example: Runtime Binding)
    my $lib = Affix::load('libmylib.so');


    for my $node (@$ast) {
        # Dynamically attach functions and types to the running interpreter
        if ($node->can('affix')) {
            $node->affix($lib);
        }
    }

=head1 DESCRIPTION

C<Affix::Bind> acts as a bridge between C/C++ header files and L<Affix>. It parses C header files to produce a
structured object model (AST) representing functions, structs, enums, typedefs, macros, and variables.

This module is designed to facilitate two primary workflows:

=over

=item Static Generation: Creating F<.pm> files to be distributed on CPAN.

=item Runtime Wrapping: Parsing headers on the fly to wrap libraries dynamically (ideal for rapid prototyping or private tooling).

=back

It attempts to normalize output between its two internal drivers (Clang and Regex) so that downstream code generation
remains consistent regardless of the environment but static source parsing is no match for LLVM.

=head1 Runtime Wrapping

If you want to use a C library immediately without creating a separate Perl module file, use the C<affix> method on the
parsed nodes.

    use Affix;
    use Affix::Bind;

    my $lib = Affix::load('libdemo.so');
    Affix::Bind->new( project_files => ['demo.h'], lib => $lib )->wrap;

    for my $node ( $binder->parse ) {

        # Define Structs, Enums, and Typedefs immediately
        if ( $node isa Affix::Bind::Typedef || $node isa Affix::Bind::Struct || $node isa Affix::Bind::Enum ) {
            $node->affix;
        }

        # Bind Functions to $lib
        elsif ( $node isa Affix::Bind::Function ) {
            $node->affix($lib);
        }

        # Pin Variables
        elsif ( $node isa Affix::Bind::Variable ) {
            # Note: Variables require a specific pinning API in Affix
            # $node->affix returns the Type object; you may need to call Affix::pin manually here
            # using $node->name and $node->affix
        }
    }

=head1 TUTORIAL: GENERATING CPAN MODULES

To create a distributable module (e.g., C<My::Lib.pm>), use the C<affix_type> method. This returns Perl source code
strings.

    use Affix::Bind;
    use Path::Tiny;

    my $binder = Affix::Bind->new( project_files => ['mylib.h'] );
    my $ast    = $binder->parse;

    my $code = <<~'PERL';
    package My::Lib;
    use v5.40;
    use Affix;

    # Load the library (user must ensure this exists)
    my $lib = Affix::load('libmylib');

    PERL

    for my $node (@$ast) {
        # Add POD documentation derived from C comments
        if ( defined $node->doc ) {
            $code .= "\n=head2 " . $node->name . "\n\n";
            $code .= $node->doc . "\n\n=cut\n";
        }

        # Generate Perl code
        # e.g. "affix $lib, 'my_func', [Int], Void;"
        if ( $node isa Affix::Bind::Function ) {
            $code .= $node->affix_type . "\n";
        }
        # e.g. "typedef MyStruct => Struct[ ... ];"
        elsif ( $node isa Affix::Bind::Typedef ) {
            $code .= $node->affix_type . ";\n";
        }
        # e.g. "use constant MAX_VAL => 100;"
        elsif ( $node isa Affix::Bind::Macro ) {
            $code .= $node->affix_type . ";\n";
        }
    }

    $code .= "\n1;\n";

    path('lib/My/Lib.pm')->spew_utf8($code);

=head1 CONSTRUCTOR

=head2 C<new( ... )>

    my $binder = Affix::Bind->new(
        project_files => [ 'lib.h' ],
        include_dirs  => [ '/usr/include' ]
    );

=over

=item C<project_files>

Required. An array reference of paths to the C header files (C<.h>, C<.hpp>, C<.hxx>) you wish to parse.

=item C<include_dirs>

Optional. An array reference of paths to search for C<#include "..."> directives. The directory of every file listed in
C<project_files> is automatically added to this list.

=back

=head1 METHODS

=head2 parse

    my @nodes = $binder->parse( $entry_point, $include_dirs );

Parses the project files and returns a list of Node objects (see B<Data Model> below). The nodes are sorted by file
name and line number to ensure deterministic output order.

=over

=item C<$entry_point>

Optional. The specific file to start parsing from. Defaults to the first file in C<project_files>.

=back

=head1 DATA MODEL

The C<parse()> method returns a list of objects inheriting from C<Affix::Bind::Entity>.

All nodes provide at least two key methods:

=over

=item * C<affix_type>: Returns a B<string> of Perl code representing the type or declaration (e.g., C<"Int">, C<"typedef Foo => Int">). Used for code generation.

=item * C<affix>: Returns the B<actual object> or performs the binding action immediately. Used for runtime wrapping.

=back

=head2 Affix::Bind::Type

Represents a generic C type (e.g., C<int>, C<void>, C<size_t>).

=head2 Affix::Bind::Type::Pointer

Represents C<T*> types. Wraps another type object.

=head2 Affix::Bind::Type::Array

Represents C<T[N]> fixed-size arrays. Wraps a type object and a count.

=head2 Affix::Bind::Type::CodeRef

Represents function pointers (callbacks), e.g., C<void (*)(int)>.

=over

=item * C<ret>: Return type object.

=item * C<params>: ArrayRef of argument type objects.

=item * C<affix_type>: Returns C<Callback[[Args] => Ret]>.

=back

=head2 Affix::Bind::Argument

Function arguments.

=head2 Affix::Bind::Member

Struct/Union members.

=over

=item * C<definition>: If the member defines a nested struct/union inline, this holds that definition object.

=item * C<affix_type>: Returns the signature of the type OR the nested definition.

=back

=head2 Affix::Bind::Function

A C function declaration.

=over

=item * C<affix_type>: Returns a complete Perl string to bind this function (e.g., C<affix $lib, name => ...>).

=back

=head2 Affix::Bind::Struct

A C struct or union definition.

=over

=item * C<tag>: Either 'struct' or 'union'.
=item * C<affix_type>: Returns C<Struct[ ... ]> or C<Union[ ... ]>.

=back

=head2 Affix::Bind::Typedef

A name alias for another type.

=over

=item * C<underlying>: The type object being aliased.

=back

B<Note:> In C, C<typedef struct { ... } Name;> results in a C<Typedef> object where C<underlying> is the C<Struct>
object.

=head2 Affix::Bind::Enum

An enumeration.

=over

=item * C<affix_type>: Returns C<Enum[ Name => Val, ... ]>. String values in enums are quoted automatically.

=back

=head2 Affix::Bind::Variable

A global C<extern> variable.

=over

=item * C<affix_type>: Returns a C<pin my $var ...> string.

=back

=head2 Affix::Bind::Macro

A preprocessor C<#define>.

=over

=item * C<affix_type>: Returns a C<use constant> string. Expressions (e.g., C<A + B>) are quoted as strings to prevent compile-time errors in Perl, while literals are preserved.

=back

=cut
